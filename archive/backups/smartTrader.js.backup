// HootBot/src/pumpTools/smartTrader.js - Enhanced with Rapid Risk Detection
// Working version that bypasses TypeScript compilation issues

const { Connection, PublicKey, LAMPORTS_PER_SOL } = require('@solana/web3.js');
const dotenv = require('dotenv');

dotenv.config();

// Import functions with error handling - use what's available
let scanAllTokens, runMindEngine, initiateCoordinatedBuy, initiateCoordinatedSell, getTokenBalance, emergencyExitPosition;
let RealTimeRiskMonitor, ProfitSniper;

// Try to import compiled modules first, then fallback to source
try {
  // Try compiled versions first
  const tokenScanner = require('../../dist/pumpTools/tokenScanner');
  scanAllTokens = tokenScanner.scanAllTokens;
  console.log('‚úÖ Loaded tokenScanner from compiled dist');
} catch (error) {
  try {
    // Fallback to TypeScript source
    const tokenScanner = require('./tokenScanner');
    scanAllTokens = tokenScanner.scanAllTokens;
    console.log('‚úÖ Loaded tokenScanner from TypeScript source');
  } catch (error2) {
    console.warn('‚ö†Ô∏è tokenScanner not available - token scanning disabled');
    scanAllTokens = async () => [];
  }
}

try {
  const mindEngine = require('../../dist/mindEngine');
  runMindEngine = mindEngine.runMindEngine;
  console.log('‚úÖ Loaded mindEngine from compiled dist');
} catch (error) {
  try {
    const mindEngine = require('../mindEngine');
    runMindEngine = mindEngine.runMindEngine;
    console.log('‚úÖ Loaded mindEngine from TypeScript source');
  } catch (error2) {
    console.warn('‚ö†Ô∏è mindEngine not available - using mock');
    runMindEngine = async () => ({
      survivabilityScore: 50,
      tradeSuggestion: { action: 'HOLD', percentage: 0, reason: 'M.I.N.D. not available' },
      panicScore: 0,
      riskLevel: 'medium'
    });
  }
}

try {
  const tradeExecutor = require('../../dist/pumpTools/tradeExecutor');
  initiateCoordinatedBuy = tradeExecutor.initiateCoordinatedBuy;
  console.log('‚úÖ Loaded tradeExecutor from compiled dist');
} catch (error) {
  try {
    const tradeExecutor = require('./tradeExecutor');
    initiateCoordinatedBuy = tradeExecutor.initiateCoordinatedBuy;
    console.log('‚úÖ Loaded tradeExecutor from TypeScript source');
  } catch (error2) {
    console.warn('‚ö†Ô∏è tradeExecutor not available - using mock');
    initiateCoordinatedBuy = async (amount) => {
      console.log(`üß™ MOCK BUY: ${amount} SOL`);
      return true;
    };
  }
}

try {
  const sellExecutor = require('../../dist/pumpTools/sellExecutor');
  initiateCoordinatedSell = sellExecutor.initiateCoordinatedSell;
  getTokenBalance = sellExecutor.getTokenBalance;
  emergencyExitPosition = sellExecutor.emergencyExitPosition;
  console.log('‚úÖ Loaded sellExecutor from compiled dist');
} catch (error) {
  console.warn('‚ö†Ô∏è sellExecutor not available - using mocks');
  initiateCoordinatedSell = async (mint, percent) => {
    console.log(`üß™ MOCK SELL: ${percent}% of ${mint}`);
    return true;
  };
  getTokenBalance = async () => 0;
  emergencyExitPosition = async (mint) => {
    console.log(`üß™ MOCK EMERGENCY EXIT: ${mint}`);
    return true;
  };
}

// Try to load enhanced modules
try {
  RealTimeRiskMonitor = require('../realTimeRiskMonitor').default;
  console.log('‚úÖ RealTimeRiskMonitor loaded');
} catch (error) {
  console.warn('‚ö†Ô∏è RealTimeRiskMonitor not available - using basic mode');
  RealTimeRiskMonitor = null;
}

try {
  const profitSniperModule = require('../profitSniper');
  ProfitSniper = profitSniperModule.ProfitSniper;
  console.log('‚úÖ ProfitSniper loaded');
} catch (error) {
  console.warn('‚ö†Ô∏è ProfitSniper not available - using basic mode');
  ProfitSniper = null;
}

// Enhanced configuration with rapid monitoring
const config = {
  // Scanner settings
  scanNewTokens: true,
  scanInterval: 1,  // Scan EVERY cycle for maximum opportunity discovery
  
  // Trading settings
  primaryToken: process.env.DUTCHBROS_TOKEN_MINT || process.env.TEST_TOKEN_ADDRESS,
  walletAddress: process.env.HOOTBOT_WALLET_ADDRESS || '3BWwMDcyS1tFtGMzZ7kYWzukjuHvkLJJtuKuVMSHsp6D',
  baseTradeAmount: 0.01,  // Base SOL per trade
  maxTradeAmount: 0.5,    // Maximum SOL per trade
  minMindScore: 60,       // Minimum MIND survivability
  
  // Timing - ENHANCED FOR RAPID DETECTION
  cycleDelay: 3 * 60 * 1000,          // 3 minutes for main discovery cycle
  rapidScanInterval: 10 * 1000,       // 10 seconds for position monitoring
  devWalletScanInterval: 5 * 1000,    // 5 seconds for dev activity
  panicDetectionInterval: 15 * 1000,  // 15 seconds for panic detection
  peakHourMultiplier: 1.5,            // Increase trades during peak hours
  
  // Risk management - ENHANCED THRESHOLDS
  maxNewTokens: 2,           // Max new tokens to try per session
  maxDailySpend: 5,          // Maximum SOL to spend per day
  panicSellThreshold: 50,    // Standard panic threshold
  stopLossPercentage: 25,    // Stop loss at 25% down
  
  // CRITICAL: Emergency exit thresholds
  EMERGENCY_THRESHOLDS: {
    PANIC_SCORE: 80,         // Emergency exit if panic > 80%
    MIND_SCORE_DROP: 30,     // Exit if M.I.N.D. drops >30 points
    SURVIVABILITY_FLOOR: 25, // Emergency exit if survivability < 25%
    DEV_DUMP_PERCENT: 15,    // Exit if dev sells >15%
  },
  
  // Profit taking - ENHANCED
  profitTarget1: 25,         // Take 10% profit at 25% gain
  profitTarget2: 50,         // Take 25% profit at 50% gain
  profitTarget3: 100,        // Take 50% profit at 100% gain
  
  // Modes
  testMode: true,            // START IN TEST MODE - CHANGE TO false FOR LIVE
  whaleMode: false,          // Enable whale-sized trades
  conservativeMode: false,   // Only trade on very strong signals
  verboseLogging: true,      // Detailed logging
  
  // NEW: Rapid monitoring toggle
  rapidMonitoringEnabled: true,  // Enable 10-second position scans
};

// Enhanced session tracking
let cycleCount = 0;
const tradedTokens = new Map(); // Original tracking for compatibility
const sessionStats = {
  totalBuys: 0,
  totalSells: 0,
  totalSpent: 0,
  totalEarned: 0,
  tokensAnalyzed: 0,
  tradesExecuted: 0,
  startTime: Date.now(),
  dailySpent: 0,
  lastDayReset: new Date().toDateString(),
  profitTaken: 0,
  emergencyExits: 0,
  rapidScansCompleted: 0
};

// Initialize enhanced systems safely
let riskMonitor = null;
let profitSniper = null;

if (RealTimeRiskMonitor && ProfitSniper) {
  try {
    riskMonitor = new RealTimeRiskMonitor();
    profitSniper = new ProfitSniper();
    profitSniper.setStrategy('CONSERVATIVE'); // Default strategy
    console.log('‚úÖ Enhanced systems initialized: RiskMonitor + ProfitSniper');
  } catch (error) {
    console.warn('‚ö†Ô∏è Enhanced modules failed to initialize:', error.message);
    console.warn('   Running in basic mode');
  }
} else {
  console.log('‚ÑπÔ∏è Running in basic mode - enhanced modules not available');
}

// Helper function to check if we're in peak trading hours
function isPeakTradingHour(peakHours) {
  if (!peakHours || peakHours.length === 0) return false;
  const currentHour = new Date().getUTCHours();
  return peakHours.includes(currentHour);
}

// Helper function to extract MIND action
function extractMindAction(mindResult) {
  if (mindResult.tradeSuggestion && mindResult.tradeSuggestion.action) {
    return mindResult.tradeSuggestion.action;
  }
  
  if (mindResult.suggestedAction) {
    const match = mindResult.suggestedAction.match(/^(\w+)/);
    return match ? match[1] : 'HOLD';
  }
  
  return 'HOLD';
}

// Enhanced trade size calculation
function calculateTradeSize(mindResult, baseAmount) {
  const survivability = mindResult.survivabilityScore || 0;
  const confidence = (mindResult.tradeSuggestion && mindResult.tradeSuggestion.percentage) || 50;
  
  let multiplier = 1.0;
  
  if (survivability >= 90 && confidence >= 75) {
    multiplier = 3.0;  // Maximum confidence
  } else if (survivability >= 80 && confidence >= 50) {
    multiplier = 2.0;  // High confidence
  } else if (survivability >= 70) {
    multiplier = 1.5;  // Good confidence
  } else if (survivability >= 60) {
    multiplier = 1.0;  // Standard
  } else {
    multiplier = 0.5;  // Reduced confidence
  }
  
  // Apply peak hour boost
  if (isPeakTradingHour(mindResult.peakTradingHours)) {
    multiplier *= config.peakHourMultiplier || 1.5;
  }
  
  const finalAmount = baseAmount * multiplier;
  return Math.min(finalAmount, config.maxTradeAmount);
}

// Enhanced position tracking with rapid monitoring integration
function trackNewPosition(tokenMint, entryData) {
  // Track in original system for compatibility
  tradedTokens.set(tokenMint, entryData);
  
  // Add to enhanced systems if available
  if (riskMonitor) {
    try {
      riskMonitor.addPosition(tokenMint, entryData.symbol || 'UNKNOWN', entryData.mindScore || 0);
    } catch (error) {
      console.warn('Warning: RiskMonitor error:', error.message);
    }
  }
  
  if (profitSniper) {
    try {
      profitSniper.trackPosition(tokenMint, entryData);
    } catch (error) {
      console.warn('Warning: ProfitSniper error:', error.message);
    }
  }
  
  console.log(`üéØ Position tracked: ${entryData.symbol || 'UNKNOWN'}`);
}

// Remove position from all tracking systems
function removePositionFromTracking(tokenMint) {
  const position = tradedTokens.get(tokenMint);
  if (position) {
    tradedTokens.delete(tokenMint);
    
    if (riskMonitor) {
      try {
        riskMonitor.removePosition(tokenMint);
      } catch (error) {
        console.warn('Warning: RiskMonitor removal error:', error.message);
      }
    }
    
    console.log(`‚úÖ Position removed from tracking: ${position.symbol || 'UNKNOWN'}`);
  }
}

// Check wallet balance
async function checkWalletBalance() {
  try {
    const connection = new Connection(
      process.env.HELIUS_RPC_URL || 'https://api.mainnet-beta.solana.com'
    );
    
    const pubkey = new PublicKey(config.walletAddress);
    const balance = await connection.getBalance(pubkey);
    const solBalance = balance / LAMPORTS_PER_SOL;
    
    return solBalance;
  } catch (error) {
    console.error('Could not check wallet balance:', error.message);
    return 0;
  }
}

// Reset daily spending limit
function checkDailyReset() {
  const today = new Date().toDateString();
  if (today !== sessionStats.lastDayReset) {
    sessionStats.dailySpent = 0;
    sessionStats.lastDayReset = today;
    console.log('üìÖ Daily spending limit reset');
  }
}

// Enhanced position monitoring with profit sniper
async function monitorPositions() {
  if (tradedTokens.size === 0) {
    return;
  }
  
  console.log('\nüíé Monitoring positions for profit opportunities...');
  
  // Use ProfitSniper if available, otherwise basic monitoring
  if (profitSniper) {
    try {
      await profitSniper.monitorAllPositions();
      const stats = profitSniper.getSessionStats();
      console.log(`üìä ProfitSniper: ${stats.activePositions} active, ${stats.totalSells} sells executed`);
    } catch (error) {
      console.warn('ProfitSniper monitoring error:', error.message);
      await basicPositionMonitoring();
    }
  } else {
    await basicPositionMonitoring();
  }
}

// Basic position monitoring fallback
async function basicPositionMonitoring() {
  console.log('üìä Basic position monitoring active');
  
  for (const [tokenMint, position] of tradedTokens.entries()) {
    try {
      console.log(`   ${position.symbol || 'UNKNOWN'}: Entry ${(position.buyPrice || position.entrySol || 0).toFixed(3)} SOL`);
      
      // Basic profit check would go here
      // For now, just log the position
      
    } catch (error) {
      console.error(`Error checking position ${position.symbol || 'UNKNOWN'}:`, error.message);
    }
  }
}

// Enhanced main trading cycle
async function enhancedSmartTradingCycle() {
  cycleCount++;
  const cycleStartTime = Date.now();
  
  console.log(`\n${'‚ïê'.repeat(70)}`);
  console.log(`ü§ñ Enhanced Smart Trader Cycle #${cycleCount}`);
  console.log(`‚è∞ Time: ${new Date().toLocaleString()}`);
  console.log(`üí∞ Daily spent: ${sessionStats.dailySpent.toFixed(3)}/${config.maxDailySpend} SOL`);
  
  // Show enhanced monitoring status if available
  if (riskMonitor) {
    try {
      const riskStatus = riskMonitor.getMonitoringStatus();
      console.log(`üîç Rapid monitoring: ${riskStatus.isActive ? '‚úÖ ACTIVE' : '‚ùå INACTIVE'}`);
      console.log(`üìä Positions under watch: ${riskStatus.positionsMonitored}`);
    } catch (error) {
      console.log(`üîç Rapid monitoring: ‚ö†Ô∏è ERROR`);
    }
  } else {
    console.log(`üîç Rapid monitoring: ‚ùå NOT AVAILABLE`);
  }
  
  if (profitSniper) {
    try {
      const profitStats = profitSniper.getSessionStats();
      console.log(`üíé ProfitSniper positions: ${profitStats.activePositions}`);
    } catch (error) {
      console.log(`üíé ProfitSniper: ‚ö†Ô∏è ERROR`);
    }
  }
  
  console.log('‚îÄ'.repeat(70));
  
  checkDailyReset();
  
  try {
    // Check if we've hit daily limit
    if (sessionStats.dailySpent >= config.maxDailySpend) {
      console.log('üìõ Daily spending limit reached. Monitoring positions only...');
      await monitorPositions();
      return;
    }
    
    // 1. Monitor existing positions for profit taking
    await monitorPositions();
    
    // 2. Check existing positions for MIND-based sell signals
    for (const [tokenMint, position] of tradedTokens.entries()) {
      if (position.emergencyExitTriggered) continue;
      
      console.log(`\nüîç Analyzing ${position.symbol || 'UNKNOWN'} for sell opportunity...`);
      
      // Temporarily switch to analyze this token
      const originalToken = process.env.HELIUS_TARGET_WALLET;
      process.env.HELIUS_TARGET_WALLET = tokenMint;
      
      try {
        const positionResult = await runMindEngine();
        const positionAction = extractMindAction(positionResult);
        
        console.log(`   M.I.N.D. Signal: ${positionAction} (${positionResult.survivabilityScore}%)`);
        console.log(`   Risk Level: ${(positionResult.riskLevel || 'UNKNOWN').toUpperCase()}`);
        console.log(`   Panic Score: ${positionResult.panicScore || 0}%`);
        
        // Check for sell conditions (non-emergency)
        if (positionAction === 'SELL' && positionResult.survivabilityScore > config.EMERGENCY_THRESHOLDS.SURVIVABILITY_FLOOR) {
          const sellPercentage = (positionResult.tradeSuggestion && positionResult.tradeSuggestion.percentage) || 50;
          
          console.log(`\nüí∞ SELL SIGNAL for ${position.symbol || 'UNKNOWN'}!`);
          console.log(`   Reason: ${(positionResult.tradeSuggestion && positionResult.tradeSuggestion.reason) || 'Risk detected'}`);
          
          if (!config.testMode) {
            try {
              const success = await initiateCoordinatedSell(tokenMint, sellPercentage);
              if (success) {
                sessionStats.totalSells++;
                // Update or remove position based on percentage sold
                if (sellPercentage >= 100) {
                  removePositionFromTracking(tokenMint);
                }
              }
            } catch (error) {
              console.error(`Sell execution error: ${error.message}`);
            }
          } else {
            console.log(`üß™ TEST MODE: Would sell ${sellPercentage}% of ${position.symbol || 'UNKNOWN'}`);
          }
        }
        
      } catch (error) {
        console.error(`Error analyzing position ${position.symbol || 'UNKNOWN'}:`, error.message);
      } finally {
        // Restore primary token
        process.env.HELIUS_TARGET_WALLET = originalToken;
      }
    }
    
    // 3. Analyze primary token for new buy opportunities
    console.log('\nüß† Running M.I.N.D. analysis for primary token...');
    
    const primaryResult = await runMindEngine();
    sessionStats.tokensAnalyzed++;
    
    // Display detailed analysis
    console.log(`\nüìä M.I.N.D. Analysis Results:`);
    console.log(`   üå± Survivability: ${primaryResult.survivabilityScore}%`);
    console.log(`   üò± Panic Score: ${primaryResult.panicScore || 0}%`);
    console.log(`   üêã Whale Activity: ${primaryResult.whaleActivity ? 'DETECTED' : 'None'}`);
    console.log(`   üìä Volume Trend: ${(primaryResult.volumeTrend || 'UNKNOWN').toUpperCase()}`);
    console.log(`   ‚ö†Ô∏è Risk Level: ${(primaryResult.riskLevel || 'UNKNOWN').toUpperCase()}`);
    console.log(`   üí∞ Suggested Action: ${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.action) || 'UNKNOWN'} (${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.percentage) || 0}%)`);
    console.log(`   üìù Reason: ${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.reason) || 'No reason provided'}`);
    
    // Display consumer profile
    if (primaryResult.consumerProfile) {
      console.log(`\nüë• Consumer Profile:`);
      console.log(`   ü¶ê Shrimps: ${primaryResult.consumerProfile.shrimpPercent.toFixed(1)}%`);
      console.log(`   üê¨ Dolphins: ${primaryResult.consumerProfile.dolphinPercent.toFixed(1)}%`);
      console.log(`   üêã Whales: ${primaryResult.consumerProfile.whalePercent.toFixed(1)}%`);
    }
    
    // Set dynamic profit strategy based on M.I.N.D. analysis
    if (profitSniper) {
      try {
        setDynamicProfitStrategy(primaryResult);
      } catch (error) {
        console.warn('ProfitSniper strategy update error:', error.message);
      }
    }
    
    // Get the action from MIND
    const mindAction = extractMindAction(primaryResult);
    
    if (config.verboseLogging) {
      console.log(`\nüîç Debug: MIND recommends ${mindAction}`);
    }
    
    // Execute trade based on MIND recommendation
    switch (mindAction) {
      case 'BUY':
        const buySize = calculateTradeSize(primaryResult, config.baseTradeAmount);
        
        console.log(`\nüéØ MIND says BUY!`);
        
        if (!config.testMode && sessionStats.dailySpent + buySize <= config.maxDailySpend) {
          console.log(`üí∏ Executing BUY: ${buySize.toFixed(3)} SOL`);
          
          try {
            await initiateCoordinatedBuy(buySize);
            
            // Track in all systems
            const positionData = {
              symbol: 'DUTCHBROS', // or extract from token data
              entryPrice: 1.0, // You'd get this from market data
              entrySol: buySize,
              mindScore: primaryResult.survivabilityScore,
              entryTime: Date.now(),
              amount: buySize,
              buyPrice: buySize, // Compatibility with existing code
              timestamp: Date.now()
            };
            
            trackNewPosition(config.primaryToken, positionData);
            
            sessionStats.tradesExecuted++;
            sessionStats.totalBuys++;
            sessionStats.totalSpent += buySize;
            sessionStats.dailySpent += buySize;
            
            console.log('‚úÖ Buy order executed and tracked');
            
          } catch (error) {
            console.error('‚ùå Buy execution failed:', error.message);
          }
        } else if (config.testMode) {
          console.log(`üß™ TEST MODE: Would buy ${buySize.toFixed(3)} SOL`);
        } else {
          console.log(`‚ö†Ô∏è Buy skipped - would exceed daily limit`);
        }
        break;
        
      case 'HOLD':
        console.log('\n‚è∏Ô∏è HOLDING - Maintaining current position');
        console.log(`   Reason: ${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.reason) || 'Waiting for better signals'}`);
        break;
        
      case 'SELL':
        console.log(`\nüìâ SELL Signal: ${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.percentage) || 50}% of position`);
        console.log(`   Reason: ${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.reason) || 'Risk increasing'}`);
        
        if (!config.testMode && tradedTokens.has(config.primaryToken)) {
          try {
            const sellPercentage = (primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.percentage) || 50;
            const success = await initiateCoordinatedSell(config.primaryToken, sellPercentage);
            if (success) {
              sessionStats.totalSells++;
              console.log(`‚úÖ Sold ${sellPercentage}% of position`);
            }
          } catch (error) {
            console.error('Sell execution error:', error.message);
          }
        } else {
          console.log('üß™ TEST MODE: Would sell here');
        }
        break;
        
      case 'EXIT':
        console.log('\nüö® EXIT SIGNAL - Critical risk detected!');
        console.log(`   Reason: ${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.reason) || 'High risk conditions'}`);
        
        if (!config.testMode && tradedTokens.has(config.primaryToken)) {
          try {
            const success = await emergencyExitPosition(config.primaryToken);
            if (success) {
              sessionStats.totalSells++;
              sessionStats.emergencyExits++;
              removePositionFromTracking(config.primaryToken);
              console.log('‚úÖ Emergency exit completed');
            }
          } catch (error) {
            console.error('Emergency exit error:', error.message);
          }
        } else {
          console.log('üß™ TEST MODE: Would emergency exit');
        }
        break;
        
      default:
        console.log(`\n‚ùì Unknown action: ${mindAction}`);
        console.log('   Defaulting to HOLD');
    }
    
    // 4. Scan for new opportunities (if enabled and available)
    if (config.scanNewTokens && cycleCount % config.scanInterval === 0 && scanAllTokens) {
      console.log('\nüîç Scanning for new token opportunities...');
      
      try {
        const connection = new Connection(
          process.env.HELIUS_RPC_URL || 'https://api.mainnet-beta.solana.com'
        );
        
        const tokens = await scanAllTokens(connection);
        
        if (tokens && tokens.length > 0 && tradedTokens.size < config.maxNewTokens) {
          console.log(`\nüéØ Found ${tokens.length} potential opportunities`);
          
          // Analyze top tokens with MIND
          for (let i = 0; i < Math.min(3, tokens.length); i++) {
            const token = tokens[i];
            
            console.log(`\nüî¨ Analyzing: ${token.symbol} (Score: ${token.score})`);
            
            // Switch to new token for analysis
            const originalToken = process.env.HELIUS_TARGET_WALLET;
            process.env.HELIUS_TARGET_WALLET = token.mint;
            
            try {
              const tokenResult = await runMindEngine();
              
              if (tokenResult.survivabilityScore >= config.minMindScore) {
                console.log(`   ‚úÖ ${token.symbol} meets criteria - M.I.N.D.: ${tokenResult.survivabilityScore}%`);
                
                if (!config.testMode) {
                  // Execute buy for new token
                  const newTokenBuySize = config.baseTradeAmount;
                  await initiateCoordinatedBuy(newTokenBuySize);
                  
                  // Track new position
                  const newPositionData = {
                    symbol: token.symbol,
                    entryPrice: 1.0,
                    entrySol: newTokenBuySize,
                    mindScore: tokenResult.survivabilityScore,
                    entryTime: Date.now(),
                    amount: newTokenBuySize,
                    buyPrice: newTokenBuySize,
                    timestamp: Date.now()
                  };
                  
                  trackNewPosition(token.mint, newPositionData);
                  
                  sessionStats.totalBuys++;
                  sessionStats.totalSpent += newTokenBuySize;
                  sessionStats.dailySpent += newTokenBuySize;
                  
                  console.log(`   üöÄ Bought ${token.symbol} and tracked`);
                } else {
                  console.log(`   üß™ TEST MODE: Would buy ${token.symbol}`);
                }
              } else {
                console.log(`   ‚ùå ${token.symbol} below threshold: ${tokenResult.survivabilityScore}%`);
              }
              
            } catch (error) {
              console.error(`Error analyzing ${token.symbol}:`, error.message);
            } finally {
              process.env.HELIUS_TARGET_WALLET = originalToken;
            }
          }
        }
      } catch (error) {
        console.error('Error in token scanning:', error.message);
      }
    }
    
    // 5. Display enhanced monitoring status
    if (riskMonitor && profitSniper) {
      try {
        const riskStatus = riskMonitor.getMonitoringStatus();
        const profitStatus = profitSniper.getSessionStats();
        
        console.log('\nüîç Enhanced Monitoring Status:');
        console.log(`   Risk Monitor: ${riskStatus.isActive ? '‚úÖ Active' : '‚ùå Inactive'}`);
        console.log(`   Positions Monitored: ${riskStatus.positionsMonitored}`);
        console.log(`   ProfitSniper: ${profitStatus.currentStrategy} strategy`);
        console.log(`   Recent Alerts: ${riskStatus.recentAlerts.length}`);
        
        if (riskStatus.recentAlerts.length > 0) {
          console.log('\n‚ö†Ô∏è Recent Risk Alerts:');
          riskStatus.recentAlerts.slice(-3).forEach(alert => {
            console.log(`   ${alert.level}: ${alert.message}`);
          });
        }
      } catch (error) {
        console.warn('Enhanced monitoring status error:', error.message);
      }
    }
    
  } catch (error) {
    console.error('\n‚ùå Cycle error:', error.message);
    if (config.verboseLogging) {
      console.error('Stack:', error.stack);
    }
  }
  
  // Show enhanced session statistics
  const sessionDuration = (Date.now() - sessionStats.startTime) / 1000 / 60; // minutes
  console.log(`\nüìä Enhanced Session Statistics:`);
  console.log(`   Duration: ${sessionDuration.toFixed(1)} minutes`);
  console.log(`   Cycles Run: ${cycleCount}`);
  console.log(`   Tokens Analyzed: ${sessionStats.tokensAnalyzed}`);
  console.log(`   Buy Orders: ${sessionStats.totalBuys}`);
  console.log(`   Sell Orders: ${sessionStats.totalSells}`);
  console.log(`   Emergency Exits: ${sessionStats.emergencyExits}`);
  console.log(`   Total Spent: ${sessionStats.totalSpent.toFixed(4)} SOL`);
  console.log(`   Active Positions: ${tradedTokens.size}`);
  console.log(`   Rapid Scans: ${sessionStats.rapidScansCompleted}`);
  
  const cycleTime = Date.now() - cycleStartTime;
  console.log(`\n‚è±Ô∏è Cycle completed in ${(cycleTime / 1000).toFixed(1)} seconds`);
  console.log(`‚è∞ Next cycle in ${(config.cycleDelay / 60000).toFixed(1)} minutes`);
}

// Set dynamic profit strategy based on M.I.N.D. analysis
function setDynamicProfitStrategy(mindResult) {
  if (!profitSniper) return;
  
  const survivability = mindResult.survivabilityScore || 0;
  const panicScore = mindResult.panicScore || 0;
  const whaleActivity = mindResult.whaleActivity;
  
  if (survivability >= 90 && panicScore < 20) {
    profitSniper.setStrategy('DIAMOND_HANDS');
  } else if (whaleActivity && survivability >= 75) {
    profitSniper.setStrategy('WHALE');
  } else if (panicScore > 50 || survivability < 60) {
    profitSniper.setStrategy('AGGRESSIVE');
  } else {
    profitSniper.setStrategy('CONSERVATIVE');
  }
}

// Main function
async function main() {
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë  ü¶â HootBot Enhanced Smart Trader v4.0 - Rapid Risk Detection! üö® ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');
  
  console.log('üìã Enhanced Configuration:');
  console.log(`   Primary Token: ${config.primaryToken}`);
  console.log(`   Wallet: ${config.walletAddress}`);
  console.log(`   Mode: ${config.testMode ? 'üß™ TEST MODE' : 'üí∞ LIVE TRADING'}`);
  console.log(`   Scanner: ${config.scanNewTokens ? '‚úÖ ENABLED' : '‚ùå DISABLED'}`);
  console.log(`   Main Cycle: ${config.cycleDelay / 60000} minutes`);
  console.log(`   üö® Rapid Monitoring: ${config.rapidMonitoringEnabled ? '‚úÖ ENABLED' : '‚ùå DISABLED'}`);
  console.log(`   üîç Position Scans: Every ${config.rapidScanInterval / 1000} seconds`);
  console.log(`   üëÄ Dev Monitoring: Every ${config.devWalletScanInterval / 1000} seconds`);
  console.log(`   üò± Panic Detection: Every ${config.panicDetectionInterval / 1000} seconds`);
  console.log(`   Base Trade Size: ${config.baseTradeAmount} SOL`);
  console.log(`   Max Trade Size: ${config.maxTradeAmount} SOL`);
  console.log(`   Daily Limit: ${config.maxDailySpend} SOL`);
  console.log(`   Min MIND Score: ${config.minMindScore}%`);
  console.log(`   Emergency Thresholds:`);
  console.log(`     - Panic Score: ${config.EMERGENCY_THRESHOLDS.PANIC_SCORE}%`);
  console.log(`     - M.I.N.D. Drop: ${config.EMERGENCY_THRESHOLDS.MIND_SCORE_DROP} points`);
  console.log(`     - Survivability Floor: ${config.EMERGENCY_THRESHOLDS.SURVIVABILITY_FLOOR}%`);
  
  // Check initial wallet balance
  const initialBalance = await checkWalletBalance();
  console.log(`\nüí∞ Starting Balance: ${initialBalance.toFixed(4)} SOL`);
  
  if (!config.testMode && initialBalance < 0.1) {
    console.log('\n‚ùå Insufficient balance for trading. Please fund your wallet.');
    process.exit(1);
  }
  
  if (config.testMode) {
    console.log('\nüß™ TEST MODE ACTIVE - No real trades will be executed');
    console.log('‚ö° Enhanced Features:');
    console.log('   - Rapid Risk Detection (10-30 second alerts)');
    console.log('   - Auto-Profit Taking with 4 strategies');
    console.log('   - Emergency Exit Protection');
    console.log('   - M.I.N.D. behavioral analysis');
    console.log('   - Graceful fallbacks for missing modules');
  } else {
    console.log('\nüö® ENHANCED LIVE TRADING MODE ACTIVE üö®');
    console.log('‚ö° All safety systems engaged');
    console.log('üéØ Risk Detection Speed: 10-30 seconds vs 3+ minutes');
  }
  
  console.log('Press Ctrl+C to stop at any time.\n');
  console.log('üöÄ Starting enhanced trading cycles...\n');
  
  // Main trading loop
  while (true) {
    await enhancedSmartTradingCycle();
    console.log('\n' + '‚ïê'.repeat(70) + '\n');
    
    // Wait for next cycle
    await new Promise(resolve => setTimeout(resolve, config.cycleDelay));
  }
}

// Enhanced graceful shutdown handler
process.on('SIGINT', async () => {
  console.log('\n\nüëã Enhanced HootBot shutting down gracefully...');
  
  // Emergency exit all positions if any critical alerts
  if (riskMonitor) {
    try {
      const riskStatus = riskMonitor.getMonitoringStatus();
      if (riskStatus.recentAlerts.some(alert => alert.level === 'CRITICAL')) {
        console.log('üö® CRITICAL ALERTS DETECTED - Emergency exiting all positions...');
        await riskMonitor.emergencyExitAll("Shutdown with critical alerts");
      }
    } catch (error) {
      console.warn('Emergency exit error during shutdown:', error.message);
    }
  }
  
  console.log('üìä Final Enhanced Session Summary:');
  console.log(`   Total Cycles: ${cycleCount}`);
  console.log(`   Tokens Discovered: ${tradedTokens.size}`);
  console.log(`   Buy Orders: ${sessionStats.totalBuys}`);
  console.log(`   Sell Orders: ${sessionStats.totalSells}`);
  console.log(`   Emergency Exits: ${sessionStats.emergencyExits}`);
  console.log(`   Total Spent: ${sessionStats.totalSpent.toFixed(4)} SOL`);
  console.log(`   Total Earned: ${sessionStats.totalEarned.toFixed(4)} SOL`);
  console.log(`   Net P&L: ${(sessionStats.totalEarned - sessionStats.totalSpent).toFixed(4)} SOL`);
  console.log(`   Session Duration: ${((Date.now() - sessionStats.startTime) / 1000 / 60).toFixed(1)} minutes`);
  
  if (profitSniper) {
    try {
      const profitStats = profitSniper.getSessionStats();
      console.log(`   ProfitSniper Sells: ${profitStats.totalSells}`);
      console.log(`   Final Strategy: ${profitStats.currentStrategy}`);
    } catch (error) {
      console.warn('ProfitSniper stats error:', error.message);
    }
  }
  
  if (tradedTokens.size > 0) {
    console.log('\nüìà Final Active Positions:');
    for (const [mint, data] of tradedTokens.entries()) {
      console.log(`   ${data.symbol || 'UNKNOWN'}: ${(data.entrySol || data.buyPrice || 0).toFixed(3)} SOL (M.I.N.D.: ${data.mindScore || 0}%)`);
    }
  }
  
  console.log('\n‚ú® Thanks for using Enhanced HootBot! ü¶âüö®');
  process.exit(0);
});

// Start the enhanced trader
if (require.main === module) {
  main().catch(error => {
    console.error('üí• Fatal error:', error);
    process.exit(1);
  });
}

module.exports = {
  enhancedSmartTradingCycle,
  trackNewPosition,
  removePositionFromTracking,
  config
};