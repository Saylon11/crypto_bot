// src/pumpTools/tradeExecutor.ts
import { Connection, Keypair, PublicKey, Transaction } from '@solana/web3.js';
import { getConnection } from '../core/bootstrap';
import { humanWalletManager } from '../core/humanWalletManager';
import { TradeData } from '../types';

/**
 * Execute trades based on M.I.N.D. directives
 * This is pure execution - no decision making
 */

export async function executeIntelligentTrade(
  tokenMint: string,
  amount: number,
  executionProfile?: string
): Promise<{ signature: string; wallet: string }> {
  console.log(`üéØ Executing intelligent trade for ${tokenMint}`);
  
  try {
    // Get wallet with human-like behavior
    const wallet = await humanWalletManager.getWalletForTrade(executionProfile);
    const connection = getConnection();
    
    // Build transaction (simplified for example)
    const transaction = new Transaction();
    // Add your swap instructions here
    
    // Send with appropriate priority based on profile
    const priorityFee = getPriorityFee(executionProfile);
    
    const signature = await connection.sendTransaction(transaction, [wallet], {
      skipPreflight: false,
      preflightCommitment: 'confirmed',
      maxRetries: 3
    });
    
    console.log(`‚úÖ Trade executed: ${signature}`);
    
    return {
      signature,
      wallet: wallet.publicKey.toBase58()
    };
    
  } catch (error) {
    console.error('‚ùå Trade execution failed:', error);
    throw error;
  }
}

export async function executeTrade(
  action: 'BUY' | 'SELL',
  amount: number,
  tokenMint: string
): Promise<void> {
  await executeIntelligentTrade(tokenMint, amount);
}

export async function initiateCoordinatedBuy(amount: number): Promise<void> {
  const tokenMint = process.env.DUTCHBROS_TOKEN_MINT || '';
  console.log(`üöÄ Initiating coordinated buy: ${amount} SOL`);
  
  try {
    // Execute with FOMO profile for coordinated buys
    await executeIntelligentTrade(tokenMint, amount, 'FOMO');
  } catch (error) {
    console.error('‚ùå Coordinated buy failed:', error);
    throw error;
  }
}

export async function executePanicBuy(multiplier: number): Promise<void> {
  const baseAmount = 0.1;
  const panicAmount = baseAmount * multiplier;
  const tokenMint = process.env.DUTCHBROS_TOKEN_MINT || '';
  
  console.log(`üö® PANIC BUY: ${panicAmount} SOL (${multiplier}x multiplier)`);
  
  try {
    // Execute with high urgency
    await executeIntelligentTrade(tokenMint, panicAmount, 'PANIC');
  } catch (error) {
    console.error('‚ùå Panic buy failed:', error);
    throw error;
  }
}

function getPriorityFee(executionProfile?: string): number {
  switch (executionProfile) {
    case 'PANIC':
    case 'FOMO':
      return 10000; // High priority
    case 'Fear':
      return 3000;  // Low priority
    default:
      return 5000;  // Normal priority
  }
}

// src/pumpTools/mindClient.ts - Fixed version
import { runMindEngine, MINDReport } from '../mindEngine';
import { fetchBehaviorFromHelius } from '../utils/apiClient';
import { WalletData, MarketState } from '../types';

export interface MindClientConfig {
  cacheTimeout?: number;
  defaultToken?: string;
}

class MindClient {
  private lastReport: MINDReport | null = null;
  private lastFetchTime: number = 0;
  private cacheTimeout: number = 60000; // 1 minute cache
  private defaultToken: string;

  constructor(config: MindClientConfig = {}) {
    this.cacheTimeout = config.cacheTimeout || 60000;
    this.defaultToken = config.defaultToken || process.env.DUTCHBROS_TOKEN_MINT || '';
  }

  /**
   * Get the current market state for a token by running MIND analysis
   */
  async getMarketState(tokenAddress: string): Promise<MarketState> {
    console.log(`üß† MIND analyzing market state for ${tokenAddress}...`);
    
    // Use cached report if recent
    if (this.lastReport && (Date.now() - this.lastFetchTime < this.cacheTimeout)) {
      return this.parseMarketState(this.lastReport);
    }

    try {
      // Run full MIND analysis
      const report = await runMindEngine();
      this.lastReport = report;
      this.lastFetchTime = Date.now();
      
      return this.parseMarketState(report);
    } catch (error) {
      console.error('‚ùå MIND analysis failed:', error);
      // Return safe defaults on error
      return {
        isDipping: false,
        isPumping: false,
        survivabilityScore: 0,
        panicScore: 0,
        devExhaustion: 0,
        recommendation: "HOLD",
        recommendedPercentage: 0,
        reason: "Analysis unavailable"
      };
    }
  }

  /**
   * Parse MIND report into simplified market state
   */
  private parseMarketState(report: MINDReport): MarketState {
    // Determine if dipping based on metrics
    const isDipping = report.marketFlowStrength < 30 || 
                     report.panicScore > 50 ||
                     (report.tradeSuggestion.action === "EXIT" || 
                      report.tradeSuggestion.action === "SELL");
    
    // Determine if pumping based on metrics
    const isPumping = report.survivabilityScore > 70 && 
                     report.marketFlowStrength > 70 &&
                     report.tradeSuggestion.action === "BUY";

    return {
      isDipping,
      isPumping,
      survivabilityScore: report.survivabilityScore,
      panicScore: report.panicScore,
      devExhaustion: report.devExhaustion || 0,
      recommendation: report.tradeSuggestion.action,
      recommendedPercentage: report.tradeSuggestion.tradeSize,
      reason: report.tradeSuggestion.reason
    };
  }

  /**
   * Get quick sentiment check without full analysis
   */
  async getQuickSentiment(walletAddress: string): Promise<number> {
    try {
      const walletData = await fetchBehaviorFromHelius(walletAddress);
      const buys = walletData.filter(w => w.type === "buy").length;
      const sells = walletData.filter(w => w.type === "sell").length;
      const total = buys + sells || 1;
      
      return (buys / total) * 100; // Buy percentage
    } catch (error) {
      console.error('‚ùå Quick sentiment check failed:', error);
      return 50; // Neutral
    }
  }

  /**
   * Check if it's a good time to trade based on MIND analysis
   */
  async shouldTrade(): Promise<{ shouldTrade: boolean; confidence: number; reason: string }> {
    const state = await this.getMarketState(this.defaultToken);
    
    if (state.recommendation === "BUY" && state.recommendedPercentage > 50) {
      return {
        shouldTrade: true,
        confidence: state.recommendedPercentage,
        reason: state.reason
      };
    }
    
    if (state.recommendation === "HOLD" || state.recommendation === "PAUSE") {
      return {
        shouldTrade: false,
        confidence: 0,
        reason: state.reason
      };
    }
    
    return {
      shouldTrade: false,
      confidence: 0,
      reason: "Market conditions unfavorable"
    };
  }
}

// Export singleton instance
export const mind = new MindClient();