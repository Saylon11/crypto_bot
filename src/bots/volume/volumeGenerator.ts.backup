// HootBot/src/bots/volume/volumeGenerator.ts
import { Connection, Keypair, PublicKey, LAMPORTS_PER_SOL } from '@solana/web3.js';
import dotenv from 'dotenv';
import bs58 from 'bs58';
import * as fs from 'fs';
import { executeBuy } from '../raid/tradeExecutor';
import { VOLUME_CONFIG } from '../config/volumeConfig';

dotenv.config();

// Statistics tracking
let volumeStats = {
  tradesExecuted: 0,
  totalVolume: 0,
  lastTradeTime: Date.now(),
  dailyVolume: 0,
  dailyReset: new Date().setHours(0, 0, 0, 0),
  walletStats: {} as Record<string, { trades: number; volume: number }>,
};

// Load all raid wallets from environment
function loadRaidWallets(): Keypair[] {
  console.log('üíº Loading raid wallets...');
  const wallets: Keypair[] = [];
  
  // Load master wallet first
  const masterWalletPath = process.env.HOOTBOT_KEYPAIR_PATH;
  if (masterWalletPath) {
    try {
      const keypairData = JSON.parse(fs.readFileSync(masterWalletPath, 'utf-8'));
      const masterWallet = Keypair.fromSecretKey(new Uint8Array(keypairData));
      wallets.push(masterWallet);
      console.log(`   ‚úÖ Master wallet: ${masterWallet.publicKey.toString().slice(0, 8)}...`);
    } catch (error) {
      console.error('   ‚ùå Error loading master wallet:', error);
    }
  }
  
  // Load 5 raid wallets
  for (let i = 1; i <= 5; i++) {
    const secretKey = process.env[`RAID_WALLET_${i}`];
    if (secretKey) {
      try {
        const wallet = Keypair.fromSecretKey(bs58.decode(secretKey));
        wallets.push(wallet);
        console.log(`   ‚úÖ Raid wallet ${i}: ${wallet.publicKey.toString().slice(0, 8)}...`);
        
        // Initialize stats for this wallet
        volumeStats.walletStats[wallet.publicKey.toString()] = { trades: 0, volume: 0 };
      } catch (error) {
        console.error(`   ‚ùå Error loading raid wallet ${i}:`, error);
      }
    }
  }
  
  console.log(`\nüìä Loaded ${wallets.length} wallets total`);
  return wallets;
}

// Get connection with fallback
function getConnection(): Connection {
  const heliusKey = process.env.HELIUS_API_KEY;
  
  if (heliusKey && heliusKey !== 'your_key' && heliusKey !== '') {
    return new Connection(
      `https://mainnet.helius-rpc.com/?api-key=${heliusKey}`,
      'confirmed'
    );
  }
  
  return new Connection('https://api.mainnet-beta.solana.com', 'confirmed');
}

// Select wallet using intelligent rotation
function selectWallet(wallets: Keypair[]): Keypair {
  // 70% chance to use a raid wallet, 30% master wallet
  const useMasterWallet = Math.random() < 0.3;
  
  if (useMasterWallet && wallets.length > 0) {
    return wallets[0]; // Master wallet is first
  }
  
  // Select from raid wallets (skip master at index 0)
  const raidWallets = wallets.slice(1);
  if (raidWallets.length === 0) return wallets[0]; // Fallback to master
  
  // Weight selection based on recent usage (prefer less used wallets)
  const walletScores = raidWallets.map(wallet => {
    const stats = volumeStats.walletStats[wallet.publicKey.toString()];
    const recentTrades = stats?.trades || 0;
    // Lower score = more likely to be selected
    return { wallet, score: recentTrades };
  });
  
  // Sort by score (least used first)
  walletScores.sort((a, b) => a.score - b.score);
  
  // Weighted selection - prefer less used wallets
  const weights = walletScores.map((_, index) => Math.pow(2, walletScores.length - index));
  const totalWeight = weights.reduce((sum, w) => sum + w, 0);
  
  let random = Math.random() * totalWeight;
  for (let i = 0; i < weights.length; i++) {
    random -= weights[i];
    if (random <= 0) {
      return walletScores[i].wallet;
    }
  }
  
  return walletScores[0].wallet; // Fallback
}

// Generate natural-looking trade amount with wallet personality
function generateTradeAmount(walletIndex: number): number {
  const now = new Date();
  const hour = now.getUTCHours();
  const dayOfWeek = now.getUTCDay();
  
  // Each wallet has slightly different trading patterns
  const walletPersonality = {
    0: { min: 0.002, max: 0.015, variance: 0.2 },    // Master: slightly larger
    1: { min: 0.001, max: 0.008, variance: 0.15 },   // Raid 1: conservative
    2: { min: 0.001, max: 0.012, variance: 0.25 },   // Raid 2: more variable
    3: { min: 0.001, max: 0.01, variance: 0.1 },     // Raid 3: consistent
    4: { min: 0.002, max: 0.009, variance: 0.18 },   // Raid 4: mid-range
    5: { min: 0.001, max: 0.011, variance: 0.22 },   // Raid 5: aggressive
  };
  
  const personality = walletPersonality[walletIndex] || walletPersonality[0];
  
  // Base amount with personality
  let baseAmount = personality.min + 
    (Math.random() * (personality.max - personality.min));
  
  // Apply personality variance
  baseAmount *= (1 + (Math.random() * 2 - 1) * personality.variance);
  
  // Peak hour boost
  if (VOLUME_CONFIG.patterns.peakHours.includes(hour)) {
    baseAmount *= VOLUME_CONFIG.patterns.peakMultiplier;
  }
  
  // Weekend reduction
  if (dayOfWeek === 0 || dayOfWeek === 6) {
    baseAmount *= VOLUME_CONFIG.patterns.weekendMultiplier;
  }
  
  // Occasional larger buy (whale simulation)
  if (Math.random() < VOLUME_CONFIG.amounts.whaleProbability) {
    baseAmount *= VOLUME_CONFIG.amounts.whaleMultiplier;
    console.log('üêã Whale buy triggered!');
  }
  
  return Math.max(0.001, Math.min(baseAmount, 0.02));
}

// Generate delay with wallet-specific patterns
function generateDelay(walletIndex: number): number {
  const { minDelayMinutes, maxDelayMinutes, avgDelayMinutes } = VOLUME_CONFIG.timing;
  
  // Each wallet has slightly different timing preferences
  const timingMultiplier = 0.8 + (walletIndex * 0.1); // 0.8x to 1.3x
  
  // Exponential distribution for natural timing
  const lambda = 1 / (avgDelayMinutes * timingMultiplier);
  let delay = -Math.log(1 - Math.random()) / lambda;
  
  // Bound the delay
  delay = Math.max(minDelayMinutes, Math.min(delay, maxDelayMinutes));
  
  // Convert to milliseconds
  return delay * 60 * 1000;
}

// Execute a single volume trade with wallet selection
export async function executeVolumeTrade(wallets: Keypair[]): Promise<boolean> {
  const tokenMint = process.env.FATBEAR_TOKEN_MINT;
  if (!tokenMint) {
    console.error('‚ùå No FATBEAR token mint configured!');
    return false;
  }
  
  const connection = getConnection();
  
  // Select wallet for this trade
  const wallet = selectWallet(wallets);
  const walletIndex = wallets.findIndex(w => w.publicKey.equals(wallet.publicKey));
  const walletName = walletIndex === 0 ? 'Master' : `Raid ${walletIndex}`;
  
  // Check wallet balance
  const balance = await connection.getBalance(wallet.publicKey);
  const balanceInSol = balance / LAMPORTS_PER_SOL;
  
  if (balanceInSol < VOLUME_CONFIG.targets.minWalletBalance) {
    console.error(`‚ùå Low balance in ${walletName} wallet: ${balanceInSol.toFixed(4)} SOL`);
    return false;
  }
  
  // Generate trade amount based on wallet personality
  const amount = generateTradeAmount(walletIndex);
  
  console.log(`\nüí´ Volume Trade #${volumeStats.tradesExecuted + 1}`);
  console.log(`   Wallet: ${walletName} (${wallet.publicKey.toString().slice(0, 8)}...)`);
  console.log(`   Amount: ${amount.toFixed(4)} SOL`);
  console.log(`   Balance: ${balanceInSol.toFixed(4)} SOL`);
  console.log(`   Time: ${new Date().toLocaleTimeString()}`);
  
  try {
    // Execute buy (always skip MIND for our own token)
    const result = await executeBuy(
      tokenMint,
      amount,
      wallet,
      connection,
      true // skipMindAnalysis
    );
    
    if (result.success) {
      // Update statistics
      volumeStats.tradesExecuted++;
      volumeStats.totalVolume += amount;
      volumeStats.dailyVolume += amount;
      volumeStats.lastTradeTime = Date.now();
      
      // Update wallet-specific stats
      const walletKey = wallet.publicKey.toString();
      if (!volumeStats.walletStats[walletKey]) {
        volumeStats.walletStats[walletKey] = { trades: 0, volume: 0 };
      }
      volumeStats.walletStats[walletKey].trades++;
      volumeStats.walletStats[walletKey].volume += amount;
      
      console.log(`‚úÖ Trade successful!`);
      console.log(`   Daily volume: ${volumeStats.dailyVolume.toFixed(4)} SOL`);
      console.log(`   Total trades: ${volumeStats.tradesExecuted}`);
      console.log(`   ${walletName} trades: ${volumeStats.walletStats[walletKey].trades}`);
      
      // Log transaction for tracking
      if (result.signature) {
        console.log(`   TX: https://solscan.io/tx/${result.signature}`);
      }
      
      return true;
    } else {
      console.error(`‚ùå Trade failed: ${result.error}`);
      return false;
    }
  } catch (error) {
    console.error('‚ùå Trade error:', error);
    return false;
  }
}

// Main multi-wallet volume generation loop
export async function runVolumeGenerator(): Promise<void> {
  console.log('ü¶â HootBot Multi-Wallet Volume Generator');
  console.log('========================================');
  
  // Load all wallets
  const wallets = loadRaidWallets();
  
  if (wallets.length < 2) {
    console.error('‚ùå Need at least 2 wallets for multi-wallet operation!');
    return;
  }
  
  console.log(`\nüìä Configuration:`);
  console.log(`Target daily volume: ${VOLUME_CONFIG.targets.dailyVolume} SOL`);
  console.log(`Trade size: ${VOLUME_CONFIG.amounts.min}-${VOLUME_CONFIG.amounts.max} SOL`);
  console.log(`Average delay: ${VOLUME_CONFIG.timing.avgDelayMinutes} minutes`);
  console.log(`Active wallets: ${wallets.length}`);
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
  
  // Check all wallet balances
  console.log('üí∞ Checking wallet balances...');
  const connection = getConnection();
  for (let i = 0; i < wallets.length; i++) {
    const balance = await connection.getBalance(wallets[i].publicKey);
    const walletName = i === 0 ? 'Master' : `Raid ${i}`;
    console.log(`   ${walletName}: ${(balance / LAMPORTS_PER_SOL).toFixed(4)} SOL`);
  }
  console.log('');
  
  // Reset daily stats at midnight
  setInterval(() => {
    const now = new Date();
    if (now.setHours(0, 0, 0, 0) > volumeStats.dailyReset) {
      console.log('\nüìä Daily stats reset');
      console.log(`Yesterday's volume: ${volumeStats.dailyVolume.toFixed(4)} SOL`);
      
      // Show wallet distribution
      console.log('Wallet activity:');
      Object.entries(volumeStats.walletStats).forEach(([key, stats]) => {
        console.log(`   ${key.slice(0, 8)}...: ${stats.trades} trades, ${stats.volume.toFixed(4)} SOL`);
      });
      
      volumeStats.dailyVolume = 0;
      volumeStats.dailyReset = now.setHours(0, 0, 0, 0);
      // Reset wallet stats
      Object.keys(volumeStats.walletStats).forEach(key => {
        volumeStats.walletStats[key] = { trades: 0, volume: 0 };
      });
    }
  }, 60000); // Check every minute
  
  let lastWalletIndex = 0;
  
  // Main loop
  while (true) {
    try {
      // Execute trade
      const success = await executeVolumeTrade(wallets);
      
      // Determine next delay based on the wallet that was used
      let delay = generateDelay(lastWalletIndex);
      
      // Consecutive buy chance (FOMO simulation) - sometimes same wallet buys again
      if (success && Math.random() < VOLUME_CONFIG.timing.consecutiveBuyChance) {
        const { min, max } = VOLUME_CONFIG.timing.fomoDelaySeconds;
        delay = (min + Math.random() * (max - min)) * 1000;
        console.log('‚ö° FOMO mode: Same wallet might buy again...');
      }
      
      // Show next trade time
      const nextTradeTime = new Date(Date.now() + delay);
      console.log(`‚è∞ Next trade at: ${nextTradeTime.toLocaleTimeString()}`);
      console.log(`   (in ${Math.round(delay / 60000)} minutes)\n`);
      
      // Wait for next trade
      await new Promise(resolve => setTimeout(resolve, delay));
      
    } catch (error) {
      console.error('‚ùå Volume generator error:', error);
      // Wait 5 minutes on error
      await new Promise(resolve => setTimeout(resolve, 300000));
    }
  }
}

// Get enhanced volume stats including wallet distribution
export function getVolumeStats() {
  return {
    ...volumeStats,
    uptime: Date.now() - volumeStats.lastTradeTime,
    averageTradeSize: volumeStats.totalVolume / Math.max(1, volumeStats.tradesExecuted),
    walletDistribution: Object.entries(volumeStats.walletStats).map(([wallet, stats]) => ({
      wallet: wallet.slice(0, 8) + '...',
      trades: stats.trades,
      volume: stats.volume,
      percentage: (stats.volume / Math.max(0.001, volumeStats.totalVolume)) * 100
    }))
  };
}

// Direct execution
if (require.main === module) {
  runVolumeGenerator()
    .catch(error => {
      console.error('Fatal error:', error);
      process.exit(1);
    });
}
