// HootBot/smartTrader.js - Enhanced with Rapid Risk Detection
// Fixed import paths - all modules are in /src/ not /dist/

const { Connection, PublicKey, LAMPORTS_PER_SOL } = require('@solana/web3.js');
const dotenv = require('dotenv');

// CRITICAL: Load .env.scanner, NOT the default .env!
dotenv.config({ path: '.env.scanner' });

// Core imports with correct paths
const { scanAllTokens } = require('../modules/tokenScanner');
const { runMindEngine } = require('./mindEngine');
const { initiateCoordinatedBuy } = require('../pumpTools/tradeExecutor');
const { 
  initiateCoordinatedSell, 
  getTokenBalance, 
  emergencyExitPosition 
} = require('../pumpTools/sellExecutor');

// Session analyzer
const { getSessionAnalyzer } = require('./sessionAnalyzer');
const analyzer = getSessionAnalyzer();

// Optional enhanced modules (may not exist yet)
let RealTimeRiskMonitor, ProfitSniper;

try {
  RealTimeRiskMonitor = require('./realTimeRiskMonitor').default;
  console.log('âœ… RealTimeRiskMonitor loaded');
} catch (error) {
  console.warn('âš ï¸ RealTimeRiskMonitor not available - using basic mode');
  RealTimeRiskMonitor = null;
}

try {
  const profitSniperModule = require('./profitSniper');
  ProfitSniper = profitSniperModule.ProfitSniper;
  console.log('âœ… ProfitSniper loaded');
} catch (error) {
  console.warn('âš ï¸ ProfitSniper not available - using basic mode');
  ProfitSniper = null;
}

// Enhanced configuration with rapid monitoring
const config = {
  // Scanner settings
  scanNewTokens: true,
  scanInterval: 1,  // Scan EVERY cycle for maximum opportunity discovery
  
  // Trading settings - from .env.scanner
  primaryToken: process.env.TOKEN_MINT || process.env.TARGET_WALLET || 'So11111111111111111111111111111111111111112', // SOL as fallback
  walletAddress: process.env.HOOTBOT_WALLET_ADDRESS || '3BWwMDcyS1tFtGMzZ7kYWzukjuHvkLJJtuKuVMSHsp6D',
  baseTradeAmount: parseFloat(process.env.BASE_TRADE_AMOUNT) || 0.01,  // From env
  maxTradeAmount: parseFloat(process.env.MAX_TRADE_AMOUNT) || 0.5,     // From env
  minMindScore: parseInt(process.env.MIN_MIND_SCORE) || 60,            // From env
  
  // Timing - ENHANCED FOR RAPID DETECTION
  cycleDelay: 3 * 60 * 1000,          // 3 minutes for main discovery cycle
  rapidScanInterval: 10 * 1000,       // 10 seconds for position monitoring
  devWalletScanInterval: 5 * 1000,    // 5 seconds for dev activity
  panicDetectionInterval: 15 * 1000,  // 15 seconds for panic detection
  peakHourMultiplier: 1.5,            // Increase trades during peak hours
  
  // Risk management - from .env.scanner
  maxNewTokens: 10,          // Allow more tokens for scanning
  maxDailySpend: parseFloat(process.env.MAX_DAILY_SPEND) || 5,         // From env
  panicSellThreshold: parseInt(process.env.PANIC_SELL_THRESHOLD) || 70, // From env
  stopLossPercentage: 25,    // Stop loss at 25% down
  minConfidence: parseInt(process.env.MIN_CONFIDENCE) || 50,           // From env
  
  // CRITICAL: Emergency exit thresholds
  EMERGENCY_THRESHOLDS: {
    PANIC_SCORE: 80,         // Emergency exit if panic > 80%
    MIND_SCORE_DROP: 30,     // Exit if M.I.N.D. drops >30 points
    SURVIVABILITY_FLOOR: 25, // Emergency exit if survivability < 25%
    DEV_DUMP_PERCENT: 15,    // Exit if dev sells >15%
  },
  
  // Profit taking - from .env.scanner
  profitTarget1: parseInt(process.env.PROFIT_TARGET_1) || 25,  // Take 10% profit at X% gain
  profitTarget2: parseInt(process.env.PROFIT_TARGET_2) || 50,  // Take 25% profit at X% gain
  profitTarget3: parseInt(process.env.PROFIT_TARGET_3) || 100, // Take 50% profit at X% gain
  
  // Modes - from .env.scanner
  testMode: process.env.TEST_MODE === 'true',      // From env
  whaleMode: false,          
  conservativeMode: false,   
  verboseLogging: process.env.DEBUG_MODE === 'true', // From env
  
  // NEW: Rapid monitoring toggle
  rapidMonitoringEnabled: true,  // Enable 10-second position scans
};

// Enhanced session tracking
let cycleCount = 0;
const tradedTokens = new Map(); // token -> position data
const sessionStats = {
  totalBuys: 0,
  totalSells: 0,
  totalSpent: 0,
  totalEarned: 0,
  tokensAnalyzed: 0,
  tradesExecuted: 0,
  startTime: Date.now(),
  dailySpent: 0,
  lastDayReset: new Date().toDateString(),
  profitTaken: 0,
  emergencyExits: 0,
  rapidScansCompleted: 0
};

// Initialize enhanced systems safely
let riskMonitor = null;
let profitSniper = null;

if (RealTimeRiskMonitor && ProfitSniper) {
  try {
    riskMonitor = new RealTimeRiskMonitor();
    profitSniper = new ProfitSniper();
    profitSniper.setStrategy('CONSERVATIVE'); // Default strategy
    console.log('âœ… Enhanced systems initialized: RiskMonitor + ProfitSniper');
  } catch (error) {
    console.warn('âš ï¸ Enhanced modules failed to initialize:', error.message);
    console.warn('   Running in basic mode');
  }
} else {
  console.log('â„¹ï¸ Running in basic mode - enhanced modules not available');
}

// Helper function to check if we're in peak trading hours
function isPeakTradingHour(peakHours) {
  if (!peakHours || peakHours.length === 0) return false;
  const currentHour = new Date().getUTCHours();
  return peakHours.includes(currentHour);
}

// Helper function to extract MIND action
function extractMindAction(mindResult) {
  if (mindResult.tradeSuggestion && mindResult.tradeSuggestion.action) {
    return mindResult.tradeSuggestion.action;
  }
  
  if (mindResult.suggestedAction) {
    const match = mindResult.suggestedAction.match(/^(\w+)/);
    return match ? match[1] : 'HOLD';
  }
  
  return 'HOLD';
}

// Enhanced trade size calculation
function calculateTradeSize(mindResult, baseAmount) {
  const survivability = mindResult.survivabilityScore || 0;
  const confidence = (mindResult.tradeSuggestion && mindResult.tradeSuggestion.percentage) || 50;
  
  let multiplier = 1.0;
  
  if (survivability >= 90 && confidence >= 75) {
    multiplier = 3.0;  // Maximum confidence
  } else if (survivability >= 80 && confidence >= 50) {
    multiplier = 2.0;  // High confidence
  } else if (survivability >= 70) {
    multiplier = 1.5;  // Good confidence
  } else if (survivability >= 60) {
    multiplier = 1.0;  // Standard
  } else {
    multiplier = 0.5;  // Reduced confidence
  }
  
  // Apply peak hour boost
  if (isPeakTradingHour(mindResult.peakTradingHours)) {
    multiplier *= config.peakHourMultiplier || 1.5;
  }
  
  const finalAmount = baseAmount * multiplier;
  return Math.min(finalAmount, config.maxTradeAmount);
}

// Enhanced position tracking with rapid monitoring integration
function trackNewPosition(tokenMint, entryData) {
  // Track in original system for compatibility
  tradedTokens.set(tokenMint, entryData);
  
  // Add to enhanced systems if available
  if (riskMonitor) {
    try {
      riskMonitor.addPosition(tokenMint, entryData.symbol || 'UNKNOWN', entryData.mindScore || 0);
    } catch (error) {
      console.warn('Warning: RiskMonitor error:', error.message);
    }
  }
  
  if (profitSniper) {
    try {
      profitSniper.trackPosition(tokenMint, entryData);
    } catch (error) {
      console.warn('Warning: ProfitSniper error:', error.message);
    }
  }
  
  console.log(`ğŸ¯ Position tracked: ${entryData.symbol || 'UNKNOWN'}`);
}

// Remove position from all tracking systems
function removePositionFromTracking(tokenMint) {
  const position = tradedTokens.get(tokenMint);
  if (position) {
    tradedTokens.delete(tokenMint);
    
    if (riskMonitor) {
      try {
        riskMonitor.removePosition(tokenMint);
      } catch (error) {
        console.warn('Warning: RiskMonitor removal error:', error.message);
      }
    }
    
    console.log(`âœ… Position removed from tracking: ${position.symbol || 'UNKNOWN'}`);
  }
}

// Check wallet balance
async function checkWalletBalance() {
  try {
    const connection = new Connection(
      process.env.HELIUS_RPC_URL || 'https://api.mainnet-beta.solana.com'
    );
    
    const pubkey = new PublicKey(config.walletAddress);
    const balance = await connection.getBalance(pubkey);
    const solBalance = balance / LAMPORTS_PER_SOL;
    
    return solBalance;
  } catch (error) {
    console.error('Could not check wallet balance:', error.message);
    return 0;
  }
}

// Reset daily spending limit
function checkDailyReset() {
  const today = new Date().toDateString();
  if (today !== sessionStats.lastDayReset) {
    sessionStats.dailySpent = 0;
    sessionStats.lastDayReset = today;
    console.log('ğŸ“… Daily spending limit reset');
  }
}

// Enhanced position monitoring with profit sniper
async function monitorPositions() {
  if (tradedTokens.size === 0) {
    return;
  }
  
  console.log('\nğŸ’ Monitoring positions for profit opportunities...');
  
  // Use ProfitSniper if available, otherwise basic monitoring
  if (profitSniper) {
    try {
      await profitSniper.monitorAllPositions();
      const stats = profitSniper.getSessionStats();
      console.log(`ğŸ“Š ProfitSniper: ${stats.activePositions} active, ${stats.totalSells} sells executed`);
    } catch (error) {
      console.warn('ProfitSniper monitoring error:', error.message);
      await basicPositionMonitoring();
    }
  } else {
    await basicPositionMonitoring();
  }
}

// Basic position monitoring fallback
async function basicPositionMonitoring() {
  console.log('ğŸ“Š Basic position monitoring active');
  
  for (const [tokenMint, position] of tradedTokens.entries()) {
    try {
      console.log(`   ${position.symbol || 'UNKNOWN'}: Entry ${(position.buyPrice || position.entrySol || 0).toFixed(3)} SOL`);
      
      // Basic profit check would go here
      // For now, just log the position
      
    } catch (error) {
      console.error(`Error checking position ${position.symbol || 'UNKNOWN'}:`, error.message);
    }
  }
}

// Set dynamic profit strategy based on M.I.N.D. analysis
function setDynamicProfitStrategy(mindResult) {
  if (!profitSniper) return;
  
  const survivability = mindResult.survivabilityScore || 0;
  const panicScore = mindResult.panicScore || 0;
  const whaleActivity = mindResult.whaleActivity;
  
  if (survivability >= 90 && panicScore < 20) {
    profitSniper.setStrategy('DIAMOND_HANDS');
  } else if (whaleActivity && survivability >= 75) {
    profitSniper.setStrategy('WHALE');
  } else if (panicScore > 50 || survivability < 60) {
    profitSniper.setStrategy('AGGRESSIVE');
  } else {
    profitSniper.setStrategy('CONSERVATIVE');
  }
}

// Enhanced main trading cycle
async function enhancedSmartTradingCycle() {
  cycleCount++;
  const cycleStartTime = Date.now();
  
  console.log(`\n${'â•'.repeat(70)}`);
  console.log(`ğŸ¤– Enhanced Smart Trader Cycle #${cycleCount}`);
  console.log(`â° Time: ${new Date().toLocaleString()}`);
  console.log(`ğŸ’° Daily spent: ${sessionStats.dailySpent.toFixed(3)}/${config.maxDailySpend} SOL`);
  
  // Show enhanced monitoring status if available
  if (riskMonitor) {
    try {
      const riskStatus = riskMonitor.getMonitoringStatus();
      console.log(`ğŸ” Rapid monitoring: ${riskStatus.isActive ? 'âœ… ACTIVE' : 'âŒ INACTIVE'}`);
      console.log(`ğŸ“Š Positions under watch: ${riskStatus.positionsMonitored}`);
    } catch (error) {
      console.log(`ğŸ” Rapid monitoring: âš ï¸ ERROR`);
    }
  } else {
    console.log(`ğŸ” Rapid monitoring: âŒ NOT AVAILABLE`);
  }
  
  if (profitSniper) {
    try {
      const profitStats = profitSniper.getSessionStats();
      console.log(`ğŸ’ ProfitSniper positions: ${profitStats.activePositions}`);
    } catch (error) {
      console.log(`ğŸ’ ProfitSniper: âš ï¸ ERROR`);
    }
  }
  
  console.log('â”€'.repeat(70));
  
  checkDailyReset();
  
  try {
    // Check if we've hit daily limit
    if (sessionStats.dailySpent >= config.maxDailySpend) {
      console.log('ğŸ“› Daily spending limit reached. Monitoring positions only...');
      await monitorPositions();
      return;
    }
    
    // 1. Monitor existing positions for profit taking
    await monitorPositions();
    
    // 2. Check existing positions for MIND-based sell signals
    for (const [tokenMint, position] of tradedTokens.entries()) {
      if (position.emergencyExitTriggered) continue;
      
      console.log(`\nğŸ” Analyzing ${position.symbol || 'UNKNOWN'} for sell opportunity...`);
      
      // Switch to new token for analysis
      const originalToken = process.env.TOKEN_MINT;
      process.env.TOKEN_MINT = tokenMint;
      
      try {
        const positionResult = await runMindEngine();
        const positionAction = extractMindAction(positionResult);
        
        console.log(`   M.I.N.D. Signal: ${positionAction} (${positionResult.survivabilityScore}%)`);
        console.log(`   Risk Level: ${(positionResult.riskLevel || 'UNKNOWN').toUpperCase()}`);
        console.log(`   Panic Score: ${positionResult.panicScore || 0}%`);
        
        // Check for sell conditions (non-emergency)
        if (positionAction === 'SELL' && positionResult.survivabilityScore > config.EMERGENCY_THRESHOLDS.SURVIVABILITY_FLOOR) {
          const sellPercentage = (positionResult.tradeSuggestion && positionResult.tradeSuggestion.percentage) || 50;
          
          console.log(`\nğŸ’° SELL SIGNAL for ${position.symbol || 'UNKNOWN'}!`);
          console.log(`   Reason: ${(positionResult.tradeSuggestion && positionResult.tradeSuggestion.reason) || 'Risk detected'}`);
          
          if (!config.testMode) {
            try {
              const success = await initiateCoordinatedSell(tokenMint, sellPercentage);
              if (success) {
                sessionStats.totalSells++;
                
                // Log the sell with analyzer
                const currentBalance = await getTokenBalance(tokenMint);
                const estimatedChange = 0; // Would calculate actual P&L here
                
                analyzer.logTrade({
                  type: estimatedChange <= -config.stopLossPercentage ? 'EXIT' : 'SELL',
                  token: position.symbol,
                  tokenMint: tokenMint,
                  amount: currentBalance * (sellPercentage / 100),
                  price: position.buyPrice * (1 + estimatedChange / 100),
                  mindScore: positionResult.survivabilityScore,
                  reason: estimatedChange <= -config.stopLossPercentage ? 'Stop loss' : 'Profit target',
                  result: estimatedChange > 0 ? 'profit' : 'loss',
                  panicScore: positionResult.panicScore
                });
                
                // Update or remove position based on percentage sold
                if (sellPercentage >= 100) {
                  removePositionFromTracking(tokenMint);
                }
              }
            } catch (error) {
              console.error(`Sell execution error: ${error.message}`);
            }
          } else {
            console.log(`ğŸ§ª TEST MODE: Would sell ${sellPercentage}% of ${position.symbol || 'UNKNOWN'}`);
          }
        }
        
      } catch (error) {
        console.error(`Error analyzing position ${position.symbol || 'UNKNOWN'}:`, error.message);
      } finally {
        // Restore token
        process.env.TOKEN_MINT = originalToken;
      }
    }
    
    // 3. Analyze primary token for new buy opportunities
    console.log('\nğŸ§  Running M.I.N.D. analysis for primary token...');
    
    // Ensure TOKEN_MINT is set for mindEngine
    process.env.TOKEN_MINT = config.primaryToken;
    
    const primaryResult = await runMindEngine();
    sessionStats.tokensAnalyzed++;
    
    // Log the MIND analysis
    analyzer.logAnalysis(primaryResult);
    
    // Display detailed analysis
    console.log(`\nğŸ“Š M.I.N.D. Analysis Results:`);
    console.log(`   ğŸŒ± Survivability: ${primaryResult.survivabilityScore}%`);
    console.log(`   ğŸ˜± Panic Score: ${primaryResult.panicScore || 0}%`);
    console.log(`   ğŸ‹ Whale Activity: ${primaryResult.whaleActivity ? 'DETECTED' : 'None'}`);
    console.log(`   ğŸ“Š Volume Trend: ${(primaryResult.volumeTrend || 'UNKNOWN').toUpperCase()}`);
    console.log(`   âš ï¸ Risk Level: ${(primaryResult.riskLevel || 'UNKNOWN').toUpperCase()}`);
    console.log(`   ğŸ’° Suggested Action: ${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.action) || 'UNKNOWN'} (${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.percentage) || 0}%)`);
    console.log(`   ğŸ“ Reason: ${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.reason) || 'No reason provided'}`);
    
    // Display consumer profile
    if (primaryResult.consumerProfile) {
      console.log(`\nğŸ‘¥ Consumer Profile:`);
      console.log(`   ğŸ¦ Shrimps: ${primaryResult.consumerProfile.shrimpPercent.toFixed(1)}%`);
      console.log(`   ğŸ¬ Dolphins: ${primaryResult.consumerProfile.dolphinPercent.toFixed(1)}%`);
      console.log(`   ğŸ‹ Whales: ${primaryResult.consumerProfile.whalePercent.toFixed(1)}%`);
    }
    
    // Set dynamic profit strategy based on M.I.N.D. analysis
    if (profitSniper) {
      try {
        setDynamicProfitStrategy(primaryResult);
      } catch (error) {
        console.warn('ProfitSniper strategy update error:', error.message);
      }
    }
    
    // Get the action from MIND
    const mindAction = extractMindAction(primaryResult);
    
    if (config.verboseLogging) {
      console.log(`\nğŸ” Debug: MIND recommends ${mindAction}`);
    }
    
    // Execute trade based on MIND recommendation
    switch (mindAction) {
      case 'BUY':
        const buySize = calculateTradeSize(primaryResult, config.baseTradeAmount);
        
        console.log(`\nğŸ¯ MIND says BUY!`);
        
        if (!config.testMode && sessionStats.dailySpent + buySize <= config.maxDailySpend) {
          console.log(`ğŸ’¸ Executing BUY: ${buySize.toFixed(3)} SOL`);
          
          try {
            await initiateCoordinatedBuy(buySize);
            
            // Track in all systems
            const positionData = {
              symbol: 'PRIMARY_TOKEN', // Use actual token symbol
              entryPrice: 1.0, // You'd get this from market data
              entrySol: buySize,
              mindScore: primaryResult.survivabilityScore,
              entryTime: Date.now(),
              amount: buySize,
              buyPrice: buySize, // Compatibility with existing code
              timestamp: Date.now()
            };
            
            trackNewPosition(config.primaryToken, positionData);
            
            sessionStats.tradesExecuted++;
            sessionStats.totalBuys++;
            sessionStats.totalSpent += buySize;
            sessionStats.dailySpent += buySize;
            
            console.log('âœ… Buy order executed and tracked');
            
          } catch (error) {
            console.error('âŒ Buy execution failed:', error.message);
          }
        } else if (config.testMode) {
          console.log(`ğŸ§ª TEST MODE: Would buy ${buySize.toFixed(3)} SOL`);
          
          // Log test trade
          analyzer.logTrade({
            type: 'BUY',
            token: 'PRIMARY_TOKEN', // Dynamic token from scanner
            tokenMint: config.primaryToken,
            amount: buySize,
            price: 1.0,
            mindScore: primaryResult.survivabilityScore,
            reason: primaryResult.tradeSuggestion?.reason || 'MIND signal',
            testMode: true
          });
        } else {
          console.log(`âš ï¸ Buy skipped - would exceed daily limit`);
        }
        break;
        
      case 'HOLD':
        console.log('\nâ¸ï¸ HOLDING - Maintaining current position');
        console.log(`   Reason: ${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.reason) || 'Waiting for better signals'}`);
        break;
        
      case 'SELL':
        console.log(`\nğŸ“‰ SELL Signal: ${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.percentage) || 50}% of position`);
        console.log(`   Reason: ${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.reason) || 'Risk increasing'}`);
        
        if (!config.testMode && tradedTokens.has(config.primaryToken)) {
          try {
            const sellPercentage = (primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.percentage) || 50;
            const success = await initiateCoordinatedSell(config.primaryToken, sellPercentage);
            if (success) {
              sessionStats.totalSells++;
              console.log(`âœ… Sold ${sellPercentage}% of position`);
            }
          } catch (error) {
            console.error('Sell execution error:', error.message);
          }
        } else {
          console.log('ğŸ§ª TEST MODE: Would sell here');
        }
        break;
        
      case 'EXIT':
        console.log('\nğŸš¨ EXIT SIGNAL - Critical risk detected!');
        console.log(`   Reason: ${(primaryResult.tradeSuggestion && primaryResult.tradeSuggestion.reason) || 'High risk conditions'}`);
        
        if (!config.testMode && tradedTokens.has(config.primaryToken)) {
          try {
            const success = await emergencyExitPosition(config.primaryToken);
            if (success) {
              sessionStats.totalSells++;
              sessionStats.emergencyExits++;
              removePositionFromTracking(config.primaryToken);
              console.log('âœ… Emergency exit completed');
            }
          } catch (error) {
            console.error('Emergency exit error:', error.message);
          }
        } else {
          console.log('ğŸ§ª TEST MODE: Would emergency exit');
        }
        break;
        
      default:
        console.log(`\nâ“ Unknown action: ${mindAction}`);
        console.log('   Defaulting to HOLD');
    }
    
    // 4. Scan for new opportunities with Gecko Terminal
    if (config.scanNewTokens && cycleCount % config.scanInterval === 0) {
      console.log('\nğŸ¦ Gecko Terminal Scanner Active...');
      
      try {
        // Import and use your working Gecko scanner
        const { scanTokens } = require('../modules/tokenScanner');
        const tokens = await scanTokens();
        
        if (tokens && tokens.length > 0 && tradedTokens.size < config.maxNewTokens) {
          console.log(`\nğŸ¯ Found ${tokens.length} tokens ($50K-$10M market cap):`);
          
          // Display top 3 opportunities
          const topTokens = tokens.slice(0, 3);
          topTokens.forEach((token, i) => {
            console.log(`\n${i + 1}. ${token.symbol}`);
            console.log(`   ğŸ“Š Score: ${token.score}/100`);
            console.log(`   ğŸ’° Market Cap: $${token.marketCap.toLocaleString()}`);
            console.log(`   ğŸ“ˆ Volume: $${token.volume.toLocaleString()}`);
            console.log(`   ğŸ’§ Liquidity: $${token.liquidity.toLocaleString()}`);
            console.log(`   ğŸ“‰ 24h Change: ${token.priceChange.toFixed(2)}%`);
            console.log(`   ğŸ·ï¸ Mint: ${token.mint}`);
          });
          
          // Analyze top tokens with MIND
          for (let i = 0; i < Math.min(3, tokens.length); i++) {
            const token = tokens[i];
            
            // Skip low scoring tokens
            if (token.score < 70) {
              console.log(`\nâ­ï¸ Skipping ${token.symbol} - score too low (${token.score})`);
              continue;
            }
            
            console.log(`\nğŸ§  M.I.N.D. analyzing ${token.symbol}...`);
            
            // Switch to new token for analysis
            const originalToken = process.env.TOKEN_MINT;
            process.env.TOKEN_MINT = token.mint;
            
            try {
              const tokenResult = await runMindEngine();
              sessionStats.tokensAnalyzed++;
              
              console.log(`\nğŸ“Š ${token.symbol} M.I.N.D. Results:`);
              console.log(`   ğŸŒ± Survivability: ${tokenResult.survivabilityScore}%`);
              console.log(`   ğŸ˜± Panic Score: ${tokenResult.panicScore || 0}%`);
              console.log(`   ğŸ“Š Action: ${tokenResult.tradeSuggestion?.action || 'WAIT'}`);
              console.log(`   ğŸ’¡ Reason: ${tokenResult.tradeSuggestion?.reason || 'No clear signal'}`);
              
              // Execute if MIND approves
              if (tokenResult.survivabilityScore >= config.minMindScore && 
                  tokenResult.tradeSuggestion?.action === 'BUY' &&
                  sessionStats.dailySpent < config.maxDailySpend) {
                
                console.log(`\nâœ… ${token.symbol} meets all criteria!`);
                
                const buySize = config.baseTradeAmount;
                
                if (!config.testMode) {
                  console.log(`ğŸ’¸ Executing buy: ${buySize} SOL`);
                  
                  try {
                    // Execute buy
                    await initiateCoordinatedBuy(buySize);
                    
                    // Track new position
                    const positionData = {
                      symbol: token.symbol,
                      entryPrice: 1.0,
                      entrySol: buySize,
                      mindScore: tokenResult.survivabilityScore,
                      entryTime: Date.now(),
                      amount: buySize,
                      buyPrice: buySize,
                      timestamp: Date.now(),
                      marketCap: token.marketCap
                    };
                    
                    trackNewPosition(token.mint, positionData);
                    
                    sessionStats.totalBuys++;
                    sessionStats.totalSpent += buySize;
                    sessionStats.dailySpent += buySize;
                    
                    console.log(`âœ… Bought ${token.symbol} - MC: $${token.marketCap.toLocaleString()}`);
                    
                    // Log the trade
                    analyzer.logTrade({
                      type: 'BUY',
                      token: token.symbol,
                      tokenMint: token.mint,
                      amount: buySize,
                      price: 1.0,
                      mindScore: tokenResult.survivabilityScore,
                      reason: 'Gecko scanner opportunity',
                      marketCap: token.marketCap
                    });
                    
                  } catch (error) {
                    console.error(`âŒ Buy failed: ${error.message}`);
                  }
                } else {
                  console.log(`ğŸ§ª TEST MODE: Would buy ${buySize} SOL of ${token.symbol}`);
                  console.log(`   Market Cap: $${token.marketCap.toLocaleString()}`);
                }
              } else {
                const reasons = [];
                if (tokenResult.survivabilityScore < config.minMindScore) {
                  reasons.push(`low survivability (${tokenResult.survivabilityScore}%)`);
                }
                if (tokenResult.tradeSuggestion?.action !== 'BUY') {
                  reasons.push(`MIND says ${tokenResult.tradeSuggestion?.action || 'WAIT'}`);
                }
                console.log(`âŒ ${token.symbol} rejected: ${reasons.join(', ')}`);
              }
              
            } catch (error) {
              console.error(`Error analyzing ${token.symbol}:`, error.message);
            } finally {
              // Restore original token
              process.env.TOKEN_MINT = originalToken;
            }
            
            // Small delay between analyses
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        } else if (tokens.length === 0) {
          console.log('ğŸ“­ No tokens found in target range ($50K-$10M)');
        } else {
          console.log(`ğŸ“­ Position limit reached (${tradedTokens.size}/${config.maxNewTokens})`);
        }
      } catch (error) {
        console.error('Scanner error:', error.message);
      }
    }
    
    // 5. Display enhanced monitoring status
    if (riskMonitor && profitSniper) {
      try {
        const riskStatus = riskMonitor.getMonitoringStatus();
        const profitStatus = profitSniper.getSessionStats();
        
        console.log('\nğŸ” Enhanced Monitoring Status:');
        console.log(`   Risk Monitor: ${riskStatus.isActive ? 'âœ… Active' : 'âŒ Inactive'}`);
        console.log(`   Positions Monitored: ${riskStatus.positionsMonitored}`);
        console.log(`   ProfitSniper: ${profitStatus.currentStrategy} strategy`);
        console.log(`   Recent Alerts: ${riskStatus.recentAlerts.length}`);
        
        if (riskStatus.recentAlerts.length > 0) {
          console.log('\nâš ï¸ Recent Risk Alerts:');
          riskStatus.recentAlerts.slice(-3).forEach(alert => {
            console.log(`   ${alert.level}: ${alert.message}`);
          });
        }
      } catch (error) {
        console.warn('Enhanced monitoring status error:', error.message);
      }
    }
    
  } catch (error) {
    console.error('\nâŒ Cycle error:', error.message);
    if (config.verboseLogging) {
      console.error('Stack:', error.stack);
    }
  }
  
  // Show enhanced session statistics
  const sessionDuration = (Date.now() - sessionStats.startTime) / 1000 / 60; // minutes
  console.log(`\nğŸ“Š Enhanced Session Statistics:`);
  console.log(`   Duration: ${sessionDuration.toFixed(1)} minutes`);
  console.log(`   Cycles Run: ${cycleCount}`);
  console.log(`   Tokens Analyzed: ${sessionStats.tokensAnalyzed}`);
  console.log(`   Buy Orders: ${sessionStats.totalBuys}`);
  console.log(`   Sell Orders: ${sessionStats.totalSells}`);
  console.log(`   Emergency Exits: ${sessionStats.emergencyExits}`);
  console.log(`   Total Spent: ${sessionStats.totalSpent.toFixed(4)} SOL`);
  console.log(`   Active Positions: ${tradedTokens.size}`);
  console.log(`   Rapid Scans: ${sessionStats.rapidScansCompleted}`);
  
  const cycleTime = Date.now() - cycleStartTime;
  console.log(`\nâ±ï¸ Cycle completed in ${(cycleTime / 1000).toFixed(1)} seconds`);
  console.log(`â° Next cycle in ${(config.cycleDelay / 60000).toFixed(1)} minutes`);
}

// Main function
async function main() {
  try {
    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘  ğŸ¦‰ HootBot Enhanced Smart Trader v4.0 - Rapid Risk Detection! ğŸš¨ â•‘');
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
    
    console.log('ğŸ“‹ Enhanced Configuration:');
    console.log(`   Primary Token: ${config.primaryToken}`);
    console.log(`   Wallet: ${config.walletAddress}`);
    console.log(`   Mode: ${config.testMode ? 'ğŸ§ª TEST MODE' : 'ğŸ’° LIVE TRADING'}`);
    console.log(`   Scanner: ${config.scanNewTokens ? 'âœ… ENABLED' : 'âŒ DISABLED'}`);
    console.log(`   Main Cycle: ${config.cycleDelay / 60000} minutes`);
    console.log(`   ğŸš¨ Rapid Monitoring: ${config.rapidMonitoringEnabled ? 'âœ… ENABLED' : 'âŒ DISABLED'}`);
    console.log(`   ğŸ” Position Scans: Every ${config.rapidScanInterval / 1000} seconds`);
    console.log(`   ğŸ‘€ Dev Monitoring: Every ${config.devWalletScanInterval / 1000} seconds`);
    console.log(`   ğŸ˜± Panic Detection: Every ${config.panicDetectionInterval / 1000} seconds`);
    console.log(`   Base Trade Size: ${config.baseTradeAmount} SOL`);
    console.log(`   Max Trade Size: ${config.maxTradeAmount} SOL`);
    console.log(`   Daily Limit: ${config.maxDailySpend} SOL`);
    console.log(`   Min MIND Score: ${config.minMindScore}%`);
    console.log(`   Emergency Thresholds:`);
    console.log(`     - Panic Score: ${config.EMERGENCY_THRESHOLDS.PANIC_SCORE}%`);
    console.log(`     - M.I.N.D. Drop: ${config.EMERGENCY_THRESHOLDS.MIND_SCORE_DROP} points`);
    console.log(`     - Survivability Floor: ${config.EMERGENCY_THRESHOLDS.SURVIVABILITY_FLOOR}%`);
    
    // Check initial wallet balance
    const initialBalance = await checkWalletBalance();
    console.log(`\nğŸ’° Starting Balance: ${initialBalance.toFixed(4)} SOL`);
    
    if (!config.testMode && initialBalance < 0.1) {
      console.log('\nâŒ Insufficient balance for trading. Please fund your wallet.');
      process.exit(1);
    }
    
    if (config.testMode) {
      console.log('\nğŸ§ª TEST MODE ACTIVE - No real trades will be executed');
      console.log('âš¡ Enhanced Features:');
      console.log('   - Rapid Risk Detection (10-30 second alerts)');
      console.log('   - Auto-Profit Taking with 4 strategies');
      console.log('   - Emergency Exit Protection');
      console.log('   - M.I.N.D. behavioral analysis');
      console.log('   - Session analysis and reporting');
    } else {
      console.log('\nğŸš¨ ENHANCED LIVE TRADING MODE ACTIVE ğŸš¨');
      console.log('âš¡ All safety systems engaged');
      console.log('ğŸ¯ Risk Detection Speed: 10-30 seconds vs 3+ minutes');
    }
    
    console.log('Press Ctrl+C to stop at any time.\n');
    console.log('ğŸš€ Starting enhanced trading cycles...\n');
    
    // Main trading loop
    while (true) {
      await enhancedSmartTradingCycle();
      console.log('\n' + 'â•'.repeat(70) + '\n');
      
      // Wait for next cycle
      await new Promise(resolve => setTimeout(resolve, config.cycleDelay));
    }
  } catch (error) {
    console.error('ğŸ’¥ Fatal error in main function:', error.message);
    if (config.verboseLogging) {
      console.error('Stack:', error.stack);
    }
    process.exit(1);
  }
}

// Enhanced graceful shutdown handler
process.on('SIGINT', async () => {
  console.log('\n\nğŸ‘‹ Enhanced HootBot shutting down gracefully...');
  
  // Emergency exit all positions if any critical alerts
  if (riskMonitor) {
    try {
      const riskStatus = riskMonitor.getMonitoringStatus();
      if (riskStatus.recentAlerts.some(alert => alert.level === 'CRITICAL')) {
        console.log('ğŸš¨ CRITICAL ALERTS DETECTED - Emergency exiting all positions...');
        await riskMonitor.emergencyExitAll("Shutdown with critical alerts");
      }
    } catch (error) {
      console.warn('Emergency exit error during shutdown:', error.message);
    }
  }
  
  console.log('ğŸ“Š Final Enhanced Session Summary:');
  console.log(`   Total Cycles: ${cycleCount}`);
  console.log(`   Tokens Discovered: ${tradedTokens.size}`);
  console.log(`   Buy Orders: ${sessionStats.totalBuys}`);
  console.log(`   Sell Orders: ${sessionStats.totalSells}`);
  console.log(`   Emergency Exits: ${sessionStats.emergencyExits}`);
  console.log(`   Total Spent: ${sessionStats.totalSpent.toFixed(4)} SOL`);
  console.log(`   Total Earned: ${sessionStats.totalEarned.toFixed(4)} SOL`);
  console.log(`   Net P&L: ${(sessionStats.totalEarned - sessionStats.totalSpent).toFixed(4)} SOL`);
  console.log(`   Session Duration: ${((Date.now() - sessionStats.startTime) / 1000 / 60).toFixed(1)} minutes`);
  
  if (profitSniper) {
    try {
      const profitStats = profitSniper.getSessionStats();
      console.log(`   ProfitSniper Sells: ${profitStats.totalSells}`);
      console.log(`   Final Strategy: ${profitStats.currentStrategy}`);
    } catch (error) {
      console.warn('ProfitSniper stats error:', error.message);
    }
  }
  
  if (tradedTokens.size > 0) {
    console.log('\nğŸ“ˆ Final Active Positions:');
    for (const [mint, data] of tradedTokens.entries()) {
      console.log(`   ${data.symbol || 'UNKNOWN'}: ${(data.entrySol || data.buyPrice || 0).toFixed(3)} SOL (M.I.N.D.: ${data.mindScore || 0}%)`);
    }
  }
  
  console.log('\nâœ¨ Thanks for using Enhanced HootBot! ğŸ¦‰ğŸš¨');
  
  // Generate final analysis report
  try {
    analyzer.generateReport();
    analyzer.exportToCSV();
  } catch (error) {
    console.error('Error generating report:', error.message);
  }
  
  process.exit(0);
});

// Start the enhanced trader
if (require.main === module) {
  main().catch(error => {
    console.error('ğŸ’¥ Fatal error:', error);
    process.exit(1);
  });
}

module.exports = {
  enhancedSmartTradingCycle,
  trackNewPosition,
  removePositionFromTracking,
  config
};

delete process.env.TARGET_TOKEN_MINT;
delete process.env.FATBEAR_TOKEN;
delete process.env.TEST_TOKEN_ADDRESS;