// enhancedTokenScanner.js - HootBot Token Scanner with Raydium + Liquidity Filtering
const axios = require('axios');
const { Connection, PublicKey } = require('@solana/web3.js');

// Configuration
const SCANNER_CONFIG = {
  MIN_LIQUIDITY_USD: 10000,      // Minimum $10k liquidity
  MIN_VOLUME_24H: 5000,          // Minimum $5k daily volume
  MAX_TOKEN_AGE: 24 * 60 * 60 * 1000, // 24 hours
  MIN_HOLDERS: 50,               // Minimum holder count
  MAX_TOP_HOLDER_PERCENT: 30,    // Max % one wallet can hold
  RAYDIUM_PROGRAM: '675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8'
};

// Liquidity cycle analysis (integrated from liquidityCycleMapper)
function analyzeLiquidityCycles(tokenData) {
  const now = Date.now();
  const recentActivity = tokenData.filter(t => now - t.timestamp < 3600000); // Last hour
  
  // Calculate hourly liquidity flow
  const liquidityFlow = recentActivity.reduce((sum, t) => sum + (t.volume || 0), 0);
  
  // Score based on consistent liquidity
  let liquidityScore = 0;
  if (liquidityFlow > 100000) liquidityScore = 100;
  else if (liquidityFlow > 50000) liquidityScore = 80;
  else if (liquidityFlow > 20000) liquidityScore = 60;
  else if (liquidityFlow > 10000) liquidityScore = 40;
  else liquidityScore = 20;
  
  return {
    score: liquidityScore,
    hourlyFlow: liquidityFlow,
    isActive: liquidityFlow > SCANNER_CONFIG.MIN_VOLUME_24H
  };
}

// Scan Raydium pools for new low-cap tokens
async function scanRaydiumPools(connection) {
  try {
    console.log('ðŸŒŠ Scanning Raydium pools for low-cap gems...');
    
    // Get Raydium pool accounts
    const raydiumProgramId = new PublicKey(SCANNER_CONFIG.RAYDIUM_PROGRAM);
    const pools = await connection.getProgramAccounts(raydiumProgramId, {
      filters: [
        { dataSize: 752 }, // Raydium V4 pool size
      ],
      commitment: 'confirmed'
    });
    
    console.log(`Found ${pools.length} Raydium pools to analyze...`);
    
    const tokens = [];
    const batchSize = 10;
    
    // Process pools in batches
    for (let i = 0; i < Math.min(pools.length, 50); i += batchSize) {
      const batch = pools.slice(i, i + batchSize);
      
      await Promise.all(batch.map(async (pool) => {
        try {
          // Decode pool data (simplified - you'd need full Raydium SDK for complete decode)
          const data = pool.account.data;
          
          // Extract token mints (positions vary based on pool version)
          const tokenA = new PublicKey(data.slice(85, 117));
          const tokenB = new PublicKey(data.slice(117, 149));
          
          // Skip if one token is SOL/USDC/USDT
          const stablecoins = [
            'So11111111111111111111111111111111111111112', // SOL
            'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
            'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB'  // USDT
          ];
          
          let targetToken = null;
          if (!stablecoins.includes(tokenA.toString())) targetToken = tokenA;
          else if (!stablecoins.includes(tokenB.toString())) targetToken = tokenB;
          
          if (!targetToken) return;
          
          // Get pool info from DexScreener for additional data
          const dexResponse = await axios.get(
            `https://api.dexscreener.com/latest/dex/tokens/${targetToken.toString()}`,
            { timeout: 3000 }
          ).catch(() => null);
          
          if (!dexResponse?.data?.pairs?.[0]) return;
          
          const pair = dexResponse.data.pairs[0];
          const volume24h = parseFloat(pair.volume?.h24 || 0);
          const liquidityUsd = parseFloat(pair.liquidity?.usd || 0);
          const priceChange = parseFloat(pair.priceChange?.h24 || 0);
          const age = Date.now() - (pair.pairCreatedAt || 0);
          
          // Apply liquidity filters
          if (liquidityUsd < SCANNER_CONFIG.MIN_LIQUIDITY_USD) return;
          if (volume24h < SCANNER_CONFIG.MIN_VOLUME_24H) return;
          if (age > SCANNER_CONFIG.MAX_TOKEN_AGE) return;
          
          // Analyze liquidity cycles
          const liquidityAnalysis = analyzeLiquidityCycles([{
            timestamp: Date.now(),
            volume: volume24h
          }]);
          
          if (!liquidityAnalysis.isActive) return;
          
          // Calculate comprehensive score
          const score = calculateTokenScore({
            volume: volume24h,
            liquidity: liquidityUsd,
            priceChange,
            age,
            liquidityScore: liquidityAnalysis.score,
            marketCap: pair.fdv || 0
          });
          
          tokens.push({
            mint: targetToken.toString(),
            symbol: pair.baseToken?.symbol || 'UNKNOWN',
            name: pair.baseToken?.name || 'Unknown',
            source: 'raydium',
            pool: pool.pubkey.toString(),
            marketCap: pair.fdv || 0,
            volume: volume24h,
            liquidity: liquidityUsd,
            priceChange,
            age: Math.floor(age / 1000 / 60), // minutes
            liquidityScore: liquidityAnalysis.score,
            hourlyFlow: liquidityAnalysis.hourlyFlow,
            score,
            url: pair.url || `https://dexscreener.com/solana/${targetToken.toString()}`
          });
          
        } catch (err) {
          // Skip problematic pools
        }
      }));
    }
    
    // Sort by score and filter top candidates
    return tokens
      .sort((a, b) => b.score - a.score)
      .slice(0, 20);
      
  } catch (error) {
    console.error('Raydium scanner error:', error.message);
    return [];
  }
}

// Enhanced DexScreener with liquidity filtering
async function scanDexScreenerEnhanced() {
  try {
    console.log('ðŸ“Š Scanning DexScreener with liquidity filters...');
    
    const response = await axios.get('https://api.dexscreener.com/latest/dex/tokens/solana', {
      timeout: 5000,
      headers: {
        'Accept': 'application/json',
        'User-Agent': 'HootBot/1.0'
      }
    });
    
    if (!response.data?.pairs) {
      console.log('No DexScreener data received');
      return [];
    }
    
    const tokens = [];
    const now = Date.now();
    
    for (const pair of response.data.pairs) {
      try {
        if (!pair?.baseToken?.address) continue;
        
        const volume24h = parseFloat(pair.volume?.h24 || 0);
        const liquidityUsd = parseFloat(pair.liquidity?.usd || 0);
        const age = now - (pair.pairCreatedAt || 0);
        const holders = pair.holders || 0;
        
        // Enhanced filters
        if (liquidityUsd < SCANNER_CONFIG.MIN_LIQUIDITY_USD) continue;
        if (volume24h < SCANNER_CONFIG.MIN_VOLUME_24H) continue;
        if (age > SCANNER_CONFIG.MAX_TOKEN_AGE) continue;
        
        // Liquidity cycle analysis
        const liquidityAnalysis = analyzeLiquidityCycles([{
          timestamp: now,
          volume: volume24h
        }]);
        
        if (!liquidityAnalysis.isActive) continue;
        
        // Additional safety checks
        const volumeToLiquidity = volume24h / liquidityUsd;
        if (volumeToLiquidity < 0.1 || volumeToLiquidity > 10) continue; // Suspicious ratios
        
        const score = calculateTokenScore({
          volume: volume24h,
          liquidity: liquidityUsd,
          priceChange: pair.priceChange?.h24 || 0,
          age,
          liquidityScore: liquidityAnalysis.score,
          marketCap: pair.fdv || 0,
          holders,
          volumeToLiquidity
        });
        
        tokens.push({
          mint: pair.baseToken.address,
          symbol: pair.baseToken.symbol || 'UNKNOWN',
          name: pair.baseToken.name || pair.baseToken.symbol,
          source: 'dexscreener',
          marketCap: pair.fdv || 0,
          volume: volume24h,
          liquidity: liquidityUsd,
          priceChange: pair.priceChange?.h24 || 0,
          age: Math.floor(age / 1000 / 60), // minutes
          holders,
          liquidityScore: liquidityAnalysis.score,
          hourlyFlow: liquidityAnalysis.hourlyFlow,
          volumeToLiquidity: volumeToLiquidity.toFixed(2),
          score,
          url: pair.url
        });
        
      } catch (err) {
        continue;
      }
    }
    
    return tokens
      .sort((a, b) => b.score - a.score)
      .slice(0, 15);
      
  } catch (error) {
    console.error('DexScreener error:', error.message);
    return [];
  }
}

// Calculate comprehensive token score
function calculateTokenScore(params) {
  const {
    volume,
    liquidity,
    priceChange,
    age,
    liquidityScore,
    marketCap,
    holders = 0,
    volumeToLiquidity = 1
  } = params;
  
  let score = 0;
  
  // Volume score (0-25 points)
  if (volume > 500000) score += 25;
  else if (volume > 200000) score += 20;
  else if (volume > 100000) score += 15;
  else if (volume > 50000) score += 10;
  else if (volume > 20000) score += 5;
  
  // Liquidity score (0-20 points)
  if (liquidity > 200000) score += 20;
  else if (liquidity > 100000) score += 15;
  else if (liquidity > 50000) score += 10;
  else if (liquidity > 20000) score += 5;
  
  // Liquidity cycle score (0-15 points)
  score += Math.floor(liquidityScore * 0.15);
  
  // Price momentum (0-15 points)
  if (priceChange > 100) score += 15;
  else if (priceChange > 50) score += 10;
  else if (priceChange > 20) score += 5;
  else if (priceChange > 0) score += 2;
  
  // Age bonus for very new tokens (0-10 points)
  const ageMinutes = age / 1000 / 60;
  if (ageMinutes < 60) score += 10;      // Less than 1 hour
  else if (ageMinutes < 180) score += 7; // Less than 3 hours
  else if (ageMinutes < 360) score += 5; // Less than 6 hours
  else if (ageMinutes < 720) score += 3; // Less than 12 hours
  
  // Market cap bonus for micro caps (0-10 points)
  if (marketCap > 0 && marketCap < 100000) score += 10;
  else if (marketCap < 500000) score += 7;
  else if (marketCap < 1000000) score += 5;
  
  // Holder distribution (0-5 points)
  if (holders > 500) score += 5;
  else if (holders > 200) score += 3;
  else if (holders > SCANNER_CONFIG.MIN_HOLDERS) score += 1;
  
  // Penalties
  if (volumeToLiquidity < 0.2) score -= 10; // Too low activity
  if (volumeToLiquidity > 5) score -= 10;   // Possibly manipulated
  if (priceChange < -20) score -= 5;        // Dumping
  
  return Math.max(0, Math.min(100, score));
}

// Main scanner combining all sources
async function scanAllTokens(connection) {
  console.log('ðŸš€ Starting comprehensive token scan...\n');
  
  // Use provided connection or create new one
  const conn = connection || new Connection(
    process.env.HELIUS_RPC_URL || 'https://api.mainnet-beta.solana.com',
    'confirmed'
  );
  
  try {
    // Run all scanners in parallel
    const [raydiumTokens, dexTokens] = await Promise.all([
      scanRaydiumPools(conn),
      scanDexScreenerEnhanced()
    ]);
    
    console.log(`\nðŸ“Š Scan Results:`);
    console.log(`   Raydium: ${raydiumTokens.length} tokens found`);
    console.log(`   DexScreener: ${dexTokens.length} tokens found`);
    
    // Combine and deduplicate
    const tokenMap = new Map();
    
    // Add all tokens to map (will naturally deduplicate by mint)
    [...raydiumTokens, ...dexTokens].forEach(token => {
      const existing = tokenMap.get(token.mint);
      if (!existing || token.score > existing.score) {
        tokenMap.set(token.mint, token);
      }
    });
    
    // Convert back to array and sort
    const allTokens = Array.from(tokenMap.values())
      .sort((a, b) => b.score - a.score);
    
    console.log(`   Total unique: ${allTokens.length} tokens\n`);
    
    // Display top 5
    if (allTokens.length > 0) {
      console.log('ðŸ† Top 5 Opportunities:');
      allTokens.slice(0, 5).forEach((token, i) => {
        console.log(`\n${i + 1}. ${token.symbol} (${token.source})`);
        console.log(`   Score: ${token.score}/100`);
        console.log(`   Liquidity: $${token.liquidity.toLocaleString()}`);
        console.log(`   Volume: $${token.volume.toLocaleString()}`);
        console.log(`   Age: ${token.age} minutes`);
        console.log(`   Liquidity Score: ${token.liquidityScore}/100`);
        console.log(`   URL: ${token.url}`);
      });
    }
    
    return allTokens;
    
  } catch (error) {
    console.error('Scanner error:', error);
    return [];
  }
}

// Export all functions
module.exports = {
  scanRaydiumPools,
  scanDexScreenerEnhanced,
  scanAllTokens,
  analyzeLiquidityCycles,
  
  // Maintain compatibility
  scanDexScreener: scanDexScreenerEnhanced,
  scanJupiterTokens: async () => {
    console.log('ðŸª Jupiter scanning moved to DexScreener integration');
    return [];
  },
  scanPumpTokens: async () => {
    console.log('ðŸŽ¯ Pump.fun tokens are found via Raydium/DexScreener');
    return [];
  }
};