// tradeExecutor.js - Full Automatic Trade Execution
const { Connection, PublicKey, LAMPORTS_PER_SOL, VersionedTransaction } = require('@solana/web3.js');
const { loadHootBotWallet } = require('../utils/walletUtils');
const fetch = require('node-fetch');
const bs58 = require('bs58');

// Get configured RPC connection
function getConnection() {
  const rpcUrl = process.env.HELIUS_RPC_URL || 'https://api.mainnet-beta.solana.com';
  return new Connection(rpcUrl, 'confirmed');
}

// Execute coordinated buy - FULLY AUTOMATIC
async function initiateCoordinatedBuy(amountSol, skipMind = false) {
  console.log(`\nüéØ Executing automatic buy: ${amountSol} SOL`);
  
  const tokenMint = process.env.TARGET_TOKEN_MINT || process.env.TEST_TOKEN_ADDRESS;
  if (!tokenMint) {
    console.error('‚ùå No token mint configured!');
    throw new Error('No token mint configured in TARGET_TOKEN_MINT');
  }

  try {
    const connection = getConnection();
    const wallet = loadHootBotWallet();
    
    console.log(`ü¶â Wallet: ${wallet.publicKey.toBase58()}`);
    console.log(`ü™ô Token: ${tokenMint}`);
    console.log(`üí∞ Amount: ${amountSol} SOL`);
    
    // Check wallet balance
    const balance = await connection.getBalance(wallet.publicKey);
    const balanceSol = balance / LAMPORTS_PER_SOL;
    console.log(`üí≥ Balance: ${balanceSol.toFixed(4)} SOL`);
    
    if (balanceSol < amountSol + 0.01) {
      console.error('‚ùå Insufficient balance!');
      return false;
    }
    
    // Prepare pump.fun transaction
    console.log('\nüì° Getting pump.fun transaction...');
    
    const requestBody = {
      publicKey: wallet.publicKey.toBase58(),
      action: 'buy',
      mint: tokenMint,
      amount: Math.floor(amountSol * LAMPORTS_PER_SOL),
      denominatedInSol: 'true',
      slippage: 10,
      priorityFee: 0.0005,
      pool: 'pump'
    };
    
    try {
      const response = await fetch('https://pumpportal.fun/api/trade-local', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Pump.fun API error:', errorText);
        
        // Try alternative approach
        return await executeFallbackBuy(tokenMint, amountSol, wallet, connection);
      }
      
      const data = await response.json();
      console.log('‚úÖ Transaction data received');
      
      // Deserialize and sign the transaction
      const txBytes = Buffer.from(data.transaction, 'base64');
      const transaction = VersionedTransaction.deserialize(txBytes);
      
      console.log('üñäÔ∏è Signing transaction...');
      transaction.sign([wallet]);
      
      // Send the transaction
      console.log('üì§ Sending transaction...');
      const signature = await connection.sendRawTransaction(transaction.serialize(), {
        skipPreflight: false,
        maxRetries: 3,
        preflightCommitment: 'confirmed'
      });
      
      console.log(`üéâ Transaction sent! Signature: ${signature}`);
      console.log(`üîç View on Solscan: https://solscan.io/tx/${signature}`);
      
      // Wait for confirmation
      console.log('‚è≥ Waiting for confirmation...');
      const confirmation = await connection.confirmTransaction(signature, 'confirmed');
      
      if (confirmation.value.err) {
        console.error('‚ùå Transaction failed:', confirmation.value.err);
        return false;
      }
      
      console.log('‚úÖ Transaction confirmed!');
      console.log(`üéØ Successfully bought ${amountSol} SOL of ${tokenMint}`);
      
      return true;
      
    } catch (error) {
      console.error('‚ùå Transaction error:', error.message);
      
      // Try fallback method
      return await executeFallbackBuy(tokenMint, amountSol, wallet, connection);
    }
    
  } catch (error) {
    console.error('‚ùå Buy execution failed:', error.message);
    return false;
  }
}

// Fallback buy method using Jupiter
async function executeFallbackBuy(tokenMint, amountSol, wallet, connection) {
  console.log('\nüîÑ Trying Jupiter aggregator as fallback...');
  
  try {
    // Get quote from Jupiter
    const quoteResponse = await fetch(
      `https://quote-api.jup.ag/v6/quote?inputMint=So11111111111111111111111111111111111111112&outputMint=${tokenMint}&amount=${Math.floor(amountSol * LAMPORTS_PER_SOL)}&slippageBps=1000`
    );
    
    if (!quoteResponse.ok) {
      throw new Error('Failed to get Jupiter quote');
    }
    
    const quoteData = await quoteResponse.json();
    console.log('‚úÖ Jupiter quote received');
    
    // Get swap transaction
    const swapResponse = await fetch('https://quote-api.jup.ag/v6/swap', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        quoteResponse: quoteData,
        userPublicKey: wallet.publicKey.toBase58(),
        wrapAndUnwrapSol: true,
        computeUnitPriceMicroLamports: 20000
      })
    });
    
    if (!swapResponse.ok) {
      throw new Error('Failed to get Jupiter swap transaction');
    }
    
    const swapData = await swapResponse.json();
    const swapTransaction = VersionedTransaction.deserialize(
      Buffer.from(swapData.swapTransaction, 'base64')
    );
    
    console.log('üñäÔ∏è Signing Jupiter transaction...');
    swapTransaction.sign([wallet]);
    
    console.log('üì§ Sending Jupiter transaction...');
    const signature = await connection.sendRawTransaction(
      swapTransaction.serialize(),
      {
        skipPreflight: false,
        maxRetries: 3
      }
    );
    
    console.log(`üéâ Jupiter transaction sent! Signature: ${signature}`);
    console.log(`üîç View on Solscan: https://solscan.io/tx/${signature}`);
    
    await connection.confirmTransaction(signature, 'confirmed');
    console.log('‚úÖ Jupiter transaction confirmed!');
    
    return true;
    
  } catch (error) {
    console.error('‚ùå Jupiter fallback failed:', error.message);
    return false;
  }
}

// Simple buy function for compatibility
async function executeBuy(tokenMint, amountSol, wallet, connection, skipMindAnalysis = false) {
  // Set the token mint and execute
  process.env.TARGET_TOKEN_MINT = tokenMint;
  return await initiateCoordinatedBuy(amountSol, skipMindAnalysis);
}

// Export all functions
module.exports = {
  initiateCoordinatedBuy,
  executeBuy,
  getConnection,
  
  // Compatibility functions
  executePanicBuy: async (multiplier = 10, skipMind = true) => {
    console.log(`üö® Panic buy with ${multiplier}x multiplier`);
    return await initiateCoordinatedBuy(0.05 * multiplier, skipMind);
  },
  
  executeIntelligentTrade: async (tokenMint, amountSol) => {
    process.env.TARGET_TOKEN_MINT = tokenMint;
    return await initiateCoordinatedBuy(amountSol, false);
  }
};